<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","__w","dqg","dqg","src","core.rs"],"content":"//! Different methods to destroy non-descriptive cores.\n\nuse itertools::Itertools;\nuse std::time::{Duration, Instant};\n\nuse crate::{\n    debug::print_orbits_nauty_style,\n    do_if_some,\n    encoding::{encode_problem, OrbitEncoding},\n    graph::Graph,\n    misc::CoreMetric,\n    permutation::Permutation,\n    quotient::{compute_generators, empty_orbits, generate_orbits, QuotientGraph},\n    sat_solving::solve_mus_kitten,\n    statistics::QuotientStatistics,\n    time, time_assign, Error, Settings,\n};\n\n/// Just give every vertex* in the core a new color.\n/// This breaks the core but changes the original graph.\n///\n/// *Well not really every vertex, but only those\n/// in bigger orbits. We don't need to recolor single vertex orbits.\n#[cfg(not(tarpaulin_include))]\nfn recolor_core(graph: \u0026mut Graph, core: \u0026[OrbitEncoding]) -\u003e Result\u003c(), Error\u003e {\n    for orbit in core {\n        for vertex in orbit.1.iter().skip(1) {\n            graph.recolor(*vertex)?;\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\nfn search_with_core_recolor(graph: \u0026mut Graph, settings: \u0026mut Settings) -\u003e Result\u003c(), Error\u003e {\n    let mut generators;\n    let mut orbits;\n    let mut quotient_graph;\n    let mut encoding;\n\n    loop {\n        let start_time = Instant::now();\n        let mut kissat_time = Duration::ZERO;\n        let mut core_size = None;\n\n        time_assign!(nauty_time, generators, compute_generators(graph, settings));\n\n        if generators.is_empty() {\n            if settings.output_orbits {\n                print_orbits_nauty_style(empty_orbits(graph.size()), None);\n            }\n            break;\n        }\n\n        time_assign!(orbit_gen_time, orbits, generate_orbits(\u0026mut generators));\n\n        time!(graph_sort_time, _sorted, graph.sort());\n\n        time_assign!(\n            quotient_gen_time,\n            quotient_graph,\n            QuotientGraph::from_graph_orbits(graph, orbits)\n        );\n        let quotient_size = quotient_graph.quotient_graph.size();\n        let (min_orbit_size, max_orbit_size) = quotient_graph.get_orbit_sizes();\n\n        time_assign!(\n            encoding_time,\n            encoding,\n            encode_problem(\u0026quotient_graph, graph)\n        );\n\n        let descriptive = if let Some((formula, dict)) = encoding {\n            time!(\n                kitten_time,\n                next_core,\n                solve_mus_kitten(formula, \u0026quotient_graph, graph, dict)?\n            );\n            kissat_time = kitten_time;\n\n            if let Some(core) = next_core {\n                core_size = Some(core.1.len());\n                // Break core with recoloring\n                recolor_core(graph, \u0026core.1)?;\n                false\n            } else {\n                //Descriptive\n                true\n            }\n        } else {\n            // Trivially descriptive\n            true\n        };\n\n        let quotient_handling_time = start_time.elapsed();\n        let quotient_stats = QuotientStatistics {\n            quotient_size,\n            core_size,\n            max_orbit_size,\n            min_orbit_size,\n            descriptive: Ok(descriptive),\n            validated: None,\n            quotient_handling_time,\n            kissat_time,\n            orbit_gen_time,\n            quotient_gen_time,\n            encoding_time,\n            orbit_sizes: Default::default(),\n        };\n        do_if_some(settings.get_stats(), |stats| {\n            stats.log_quotient_statistic(quotient_stats);\n            stats.log_nauty_step(nauty_time);\n            stats.log_graph_sorted_step(graph_sort_time);\n            stats.log_iteration();\n        });\n\n        if descriptive {\n            do_if_some(settings.get_stats(), |stats| stats.exhausted = true);\n            if settings.output_orbits {\n                print_orbits_nauty_style(quotient_graph.orbits, None);\n            }\n            break;\n        }\n    }\n\n    do_if_some(settings.get_stats(), |stats| {\n        stats.log_end();\n        stats.save_statistics().unwrap();\n    });\n\n    Ok(())\n}\n\n/// Take the power of generators related to the core.\n/// If a generator becomes the identity, it's removed.\n#[cfg(not(tarpaulin_include))]\nfn power_generators(generators: \u0026mut [(Permutation, usize)], core: \u0026[OrbitEncoding]) {\n    for (generator, n) in generators {\n        if *n == 0 {\n            continue;\n        }\n\n        for (start, orbit) in core {\n            let image = generator.evaluate(start);\n            if let Some(image) = image {\n                if image != *start \u0026\u0026 orbit.contains(\u0026image) {\n                    *n += 1;\n                    break;\n                }\n            }\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn search_with_core_power_generators(\n    graph: \u0026mut Graph,\n    settings: \u0026mut Settings,\n) -\u003e Result\u003c(), Error\u003e {\n    let mut generators = compute_generators(graph, settings);\n    let mut orig_generators = generators\n        .iter()\n        .cloned()\n        .map(|perm| (perm, 1usize))\n        .collect_vec();\n\n    graph.sort();\n    let mut orbits;\n    let mut quotient_graph;\n    let mut encoding;\n    let mut counter = 0;\n\n    loop {\n        if orig_generators.is_empty() {\n            println!(\"removed all symmetries in {} iterations\", counter);\n            if settings.output_orbits {\n                print_orbits_nauty_style(empty_orbits(graph.size()), None);\n            }\n            return Ok(());\n        }\n\n        orbits = generate_orbits(\u0026mut generators);\n        quotient_graph = QuotientGraph::from_graph_orbits(graph, orbits);\n        encoding = encode_problem(\u0026quotient_graph, graph);\n\n        if let Some((formula, dict)) = encoding {\n            let next_core = solve_mus_kitten(formula, \u0026quotient_graph, graph, dict)?;\n            if let Some(core) = next_core {\n                power_generators(\u0026mut orig_generators, \u0026core.1);\n            } else {\n                println!(\"Descriptive\");\n                break;\n            }\n        } else {\n            println!(\"Trivially descriptive\");\n            break;\n        }\n\n        generators = orig_generators\n            .iter_mut()\n            .map(|(perm, n)| {\n                let power = perm.nth_power_of(*n);\n                if power.is_identity() {\n                    *n = 0;\n                }\n                power\n            })\n            .collect_vec();\n        orig_generators.retain(|(_, n)| *n \u003e 0);\n\n        counter += 1;\n\n        if counter \u003e 30 {\n            println!(\"Too many iterations.\");\n            break;\n        }\n    }\n\n    if settings.output_orbits {\n        print_orbits_nauty_style(quotient_graph.orbits, None);\n    }\n    println!(\"Took {} iterations\", counter);\n    Ok(())\n}\n\n/// Combine all related generators by composing them in order.\n/// If there is only one generator related, remove it.\nfn merge_generators(generators: Vec\u003cPermutation\u003e, core: \u0026[OrbitEncoding]) -\u003e Vec\u003cPermutation\u003e {\n    let mut next_generators = Vec::new();\n\n    let (involved, mut not_involved) =\n        generators\n            .into_iter()\n            .partition::\u003cVec\u003cPermutation\u003e, _\u003e(|generator| {\n                for (start, orbit) in core {\n                    let image = generator.evaluate(start);\n                    if let Some(image) = image {\n                        if image != *start \u0026\u0026 orbit.contains(\u0026image) {\n                            return true;\n                        }\n                    }\n                }\n                false\n            });\n\n    if involved.len() \u003e 1 {\n        let merged = involved\n            .into_iter()\n            .reduce(|first, second| first.merge(second).unwrap());\n        if let Some(merged) = merged {\n            next_generators.push(merged);\n        }\n    }\n\n    next_generators.append(\u0026mut not_involved);\n\n    next_generators\n}\n\n#[cfg(not(tarpaulin_include))]\nfn search_with_core_merge_generators(\n    graph: \u0026mut Graph,\n    settings: \u0026mut Settings,\n) -\u003e Result\u003c(), Error\u003e {\n    let mut generators = compute_generators(graph, settings);\n    graph.sort();\n    let mut orbits;\n    let mut quotient_graph;\n    let mut encoding;\n    let mut counter = 0;\n\n    loop {\n        if generators.is_empty() {\n            println!(\"removed all symmetries in {} iterations\", counter);\n            if settings.output_orbits {\n                print_orbits_nauty_style(empty_orbits(graph.size()), None);\n            }\n            return Ok(());\n        }\n\n        orbits = generate_orbits(\u0026mut generators);\n        quotient_graph = QuotientGraph::from_graph_orbits(graph, orbits);\n        encoding = encode_problem(\u0026quotient_graph, graph);\n\n        if let Some((formula, dict)) = encoding {\n            let next_core = solve_mus_kitten(formula, \u0026quotient_graph, graph, dict)?;\n            if let Some(core) = next_core {\n                generators = merge_generators(generators, \u0026core.1);\n            } else {\n                println!(\"Descriptive\");\n                break;\n            }\n        } else {\n            println!(\"Trivially descriptive\");\n            break;\n        }\n\n        counter += 1;\n    }\n\n    if settings.output_orbits {\n        print_orbits_nauty_style(quotient_graph.orbits, None);\n    }\n    println!(\"Took {} iterations\", counter);\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn search_with_core(graph: \u0026mut Graph, settings: \u0026mut Settings) -\u003e Result\u003c(), Error\u003e {\n    match settings.nondescriptive_core {\n        Some(CoreMetric::Recolor) =\u003e search_with_core_recolor(graph, settings),\n        Some(CoreMetric::PowerGenerators) =\u003e search_with_core_power_generators(graph, settings),\n        Some(CoreMetric::MergeGenerators) =\u003e search_with_core_merge_generators(graph, settings),\n        _ =\u003e unreachable!(),\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_merge_generators() {\n        let generators = vec![\n            Permutation::new(vec![0, 1, 2, 3, 5, 4]),\n            Permutation::new(vec![0, 2, 1, 3, 4, 5]),\n            Permutation::new(vec![0, 2, 1, 4, 3, 5]),\n            Permutation::new(vec![0, 5, 2, 4, 3, 1]),\n        ];\n        let core = vec![(3, vec![3, 4])];\n\n        let expected = vec![\n            Permutation::new(vec![0, 2, 5, 3, 4, 1]),\n            Permutation::new(vec![0, 1, 2, 3, 5, 4]),\n            Permutation::new(vec![0, 2, 1, 3, 4, 5]),\n        ];\n        let merged = merge_generators(generators, \u0026core);\n        assert_eq!(expected, merged);\n\n        let generators = vec![\n            Permutation::new(vec![0, 1, 2, 3, 5, 4]),\n            Permutation::new(vec![0, 2, 1, 3, 4, 5]),\n            Permutation::new(vec![0, 2, 1, 4, 3, 5]),\n            Permutation::new(vec![0, 5, 3, 2, 4, 1]),\n        ];\n        let core = vec![(3, vec![3, 4])];\n\n        let expected = vec![\n            Permutation::new(vec![0, 1, 2, 3, 5, 4]),\n            Permutation::new(vec![0, 2, 1, 3, 4, 5]),\n            Permutation::new(vec![0, 5, 3, 2, 4, 1]),\n        ];\n        let merged = merge_generators(generators, \u0026core);\n        assert_eq!(expected, merged);\n    }\n}\n","traces":[{"line":229,"address":[1562563,1562524,1561696],"length":1,"stats":{"Line":1},"fn_name":"merge_generators"},{"line":230,"address":[1561728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[1561970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[769120],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":236,"address":[769217,769139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[769250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[769263,769293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[769301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[769349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[769205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1562038,1562092,1562374],"length":1,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[1562118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[769540,769360,769405],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":251,"address":[1562206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1562354,1562310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1562108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1562399],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","__w","dqg","dqg","src","debug.rs"],"content":"//! Debug facilities.\nuse flussab_cnf::cnf::{write_clause, write_header, Header};\nuse itertools::Itertools;\nuse kissat_rs::Literal;\nuse nom::error::{VerboseError, VerboseErrorKind};\nuse std::{\n    fmt::{self, Debug, Display},\n    io::{self, Write},\n    time::Duration,\n};\n\nuse crate::{\n    encoding::{Clause, HighLevelEncoding, QuotientGraphEncoding},\n    graph::{Graph, GraphError, VertexIndex},\n    parser::{BinParseError, ParseError},\n    permutation::Permutation,\n    quotient::Orbits,\n    statistics::{OrbitStatistics, Statistics},\n};\n\n// Error types and From\u003c...\u003e implementations\n\n#[derive(Debug)]\npub struct MetricError(pub String);\n\nimpl Display for MetricError {\n    #[cfg(not(tarpaulin_include))]\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        std::fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"Graph initialization error\")]\n    GraphError(GraphError),\n    #[error(\"Error while parsing input file with graph description\")]\n    ParseError(Vec\u003cVerboseErrorKind\u003e),\n    #[error(\"Error while parsing graph from command line\")]\n    CLIParseError(io::Error),\n    #[error(\"Error while calling Kissat\")]\n    KissatError(kissat_rs::Error),\n    #[error(\"Unknown metric used\")]\n    MetricError(MetricError),\n}\n\nimpl From\u003cGraphError\u003e for Error {\n    #[cfg(not(tarpaulin_include))]\n    fn from(ge: GraphError) -\u003e Self {\n        Self::GraphError(ge)\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn handle_nom_verbose_error\u003cE: Debug\u003e(\n    should_print: bool,\n    verbose: VerboseError\u003cE\u003e,\n) -\u003e Vec\u003cVerboseErrorKind\u003e {\n    verbose\n        .errors\n        .into_iter()\n        .map(|(msg, kind)| {\n            if should_print {\n                eprintln!(\"{:?}\", msg);\n            }\n            kind\n        })\n        .collect()\n}\n\nimpl\u003c'a\u003e From\u003cnom::Err\u003cParseError\u003c'a\u003e\u003e\u003e for Error {\n    #[cfg(not(tarpaulin_include))]\n    fn from(pe: nom::Err\u003cParseError\u003c'a\u003e\u003e) -\u003e Self {\n        match pe {\n            nom::Err::Error(verbose) | nom::Err::Failure(verbose) =\u003e {\n                Self::ParseError(handle_nom_verbose_error(true, verbose))\n            }\n            nom::Err::Incomplete(_) =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cnom::Err\u003cBinParseError\u003c'a\u003e\u003e\u003e for Error {\n    #[cfg(not(tarpaulin_include))]\n    fn from(pe: nom::Err\u003cBinParseError\u003c'a\u003e\u003e) -\u003e Self {\n        match pe {\n            nom::Err::Error(verbose) | nom::Err::Failure(verbose) =\u003e {\n                Self::ParseError(handle_nom_verbose_error(false, verbose))\n            }\n            nom::Err::Incomplete(_) =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl From\u003ckissat_rs::Error\u003e for Error {\n    #[cfg(not(tarpaulin_include))]\n    fn from(ke: kissat_rs::Error) -\u003e Self {\n        Self::KissatError(ke)\n    }\n}\n\nimpl From\u003cio::Error\u003e for Error {\n    #[cfg(not(tarpaulin_include))]\n    fn from(ie: io::Error) -\u003e Self {\n        Self::CLIParseError(ie)\n    }\n}\n\nimpl From\u003cMetricError\u003e for Error {\n    #[cfg(not(tarpaulin_include))]\n    fn from(me: MetricError) -\u003e Self {\n        Self::MetricError(me)\n    }\n}\n\n// Custom debug methods\n\nimpl fmt::Debug for OrbitStatistics {\n    #[cfg(not(tarpaulin_include))]\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.orbit_sizes.fmt(f)\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn _print_clause\u003c'a\u003e(clause: impl Iterator\u003cItem = \u0026'a Literal\u003e) {\n    print!(\"(\");\n    itertools::Itertools::intersperse(\n        clause.map(|literal| {\n            if *literal \u003c 0 {\n                format!(\"¬{}\", -1 * literal)\n            } else {\n                format!(\"{}\", literal)\n            }\n        }),\n        \" ∨ \".to_string(),\n    )\n    .for_each(|part| print!(\"{}\", part));\n\n    println!(\") ∧\");\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn _print_formula(formula: impl Iterator\u003cItem = Clause\u003e) {\n    formula.for_each(|clause| _print_clause(clause.iter()));\n    println!(\"True\");\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn write_formula_dimacs(\n    writer: \u0026mut impl Write,\n    formula: \u0026[Clause],\n    variable_number: usize,\n) -\u003e Result\u003c(), Error\u003e {\n    let header = Header {\n        var_count: variable_number,\n        clause_count: formula.len(),\n    };\n    let mut writer = flussab::DeferredWriter::from_write(writer);\n    write_header(\u0026mut writer, header);\n\n    for clause in formula {\n        write_clause(\u0026mut writer, clause);\n    }\n\n    writer.flush().map_err(Error::from)\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn print_orbits_nauty_style(orbits: Orbits, statistics: Option\u003c\u0026Statistics\u003e) {\n    // This is necessary to give a correct\n    // start point for the output.\n    let runtime = if let Some(statistics) = statistics {\n        statistics.start_time.elapsed()\n    } else {\n        Duration::ZERO\n    };\n    println!(\"cpu time = {:.6} seconds\", runtime.as_secs_f64());\n\n    orbits\n        .encode_high()\n        .into_iter()\n        .for_each(|(orbit, members)| {\n            if members.len() \u003e 1 {\n                members.iter().for_each(|member| print!(\"{} \", member));\n                print!(\"({}); \", members.len());\n            } else {\n                print!(\"{}; \", orbit);\n            }\n        });\n\n    // Force new line and flush everything out.\n    println!();\n    std::io::stdout()\n        .flush()\n        .expect(\"Why would stdout not be flushed?\");\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn print_generator(mut generator: Permutation) {\n    let cycles = generator.get_cycles();\n\n    if cycles.is_empty() {\n        println!(\"Identity permutation.\");\n        return;\n    }\n\n    for cycle in cycles {\n        print!(\"(\");\n        Itertools::intersperse(\n            cycle.iter().map(|vertex| vertex.to_string()),\n            \" \".to_string(),\n        )\n        .for_each(|ele| print!(\"{}\", ele));\n        print!(\") \");\n    }\n    println!();\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn _print_dot(quotient_encoding: QuotientGraphEncoding, graph: \u0026Graph) -\u003e Result\u003c(), Error\u003e {\n    println!(\"graph graphname {{\");\n\n    let colors = vec![\"red\", \"green\", \"blue\", \"black\", \"yellow\", \"orange\"]; // I don't expect to print more than 4 orbits at a time with one color per orbit.\n\n    let mut vertices_in_core = quotient_encoding\n        .1\n        .iter()\n        .flat_map(|(_, vertices)| vertices)\n        .cloned()\n        .collect::\u003cVec\u003cVertexIndex\u003e\u003e();\n    vertices_in_core.sort_unstable();\n\n    for (orbit, color) in quotient_encoding.1.iter().zip(colors) {\n        for vertex in orbit.1.iter() {\n            println!(\"{:?} [color={:?}];\", vertex, color);\n            for end in graph.get_vertex(*vertex)?.edges_to.iter() {\n                if vertex \u003c end \u0026\u0026 vertices_in_core.binary_search(end).is_ok() {\n                    println!(\"{:?} -- {:?};\", vertex, end);\n                }\n            }\n        }\n    }\n\n    println!(\"}}\");\n    Ok(())\n}\n\n// Custom formatter for debug printing\n\n#[cfg(not(tarpaulin_include))]\npub fn opt_fmt\u003cT: fmt::Debug\u003e(option: \u0026Option\u003cT\u003e, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    match option {\n        Some(val) =\u003e val.fmt(f),\n        None =\u003e write!(f, \"None\"),\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn result_fmt\u003cT: fmt::Debug, E: fmt::Debug\u003e(\n    result: \u0026Result\u003cT, E\u003e,\n    f: \u0026mut fmt::Formatter\u003c'_\u003e,\n) -\u003e fmt::Result {\n    match result {\n        Ok(val) =\u003e val.fmt(f),\n        Err(e) =\u003e e.fmt(f),\n    }\n}\n\n#[allow(clippy::ptr_arg)]\n#[cfg(not(tarpaulin_include))]\npub fn bin_fmt(vec: \u0026Vec\u003cu64\u003e, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    write!(f, \"{{\")?;\n    for number in vec {\n        write!(f, \"{:#066b}\", number)?;\n    }\n    write!(f, \"}}\")?;\n\n    Ok(())\n}\n\n// Debug macros that allow to time single expressions\n\n#[macro_export]\nmacro_rules! time {\n    ($i:ident, $ret:ident, $exp:expr) =\u003e {\n        let before = std::time::Instant::now();\n        let $ret = $exp;\n        let $i = before.elapsed();\n    };\n}\n\n#[macro_export]\nmacro_rules! print_time {\n    ($name:expr, $ret:ident, $exp:expr) =\u003e {\n        let before = std::time::Instant::now();\n        let $ret = $exp;\n        println!(\"{} took {:?}\", $name, before.elapsed());\n    };\n}\n\n#[macro_export]\nmacro_rules! time_mut {\n    ($i:ident, $ret:ident, $exp:expr) =\u003e {\n        let before = std::time::Instant::now();\n        let mut $ret = $exp;\n        let $i = before.elapsed();\n    };\n}\n\n#[macro_export]\nmacro_rules! print_time_mut {\n    ($name:expr, $ret:ident, $exp:expr) =\u003e {\n        let before = std::time::Instant::now();\n        let mut $ret = $exp;\n        println!(\"{} took {:?}\", $name, before.elapsed());\n    };\n}\n\n#[macro_export]\nmacro_rules! time_assign {\n    ($name:ident, $ret:ident, $exp:expr) =\u003e {\n        let before = std::time::Instant::now();\n        $ret = $exp;\n        let $name = before.elapsed();\n    };\n}\n\n#[macro_export]\nmacro_rules! parse_single_line {\n    ($ret:ident, $exp:expr) =\u003e {\n        let (res, $ret) = $exp?;\n        eof::\u003c$crate::parser::Input\u003c'_\u003e, $crate::parser::ParseError\u003c'_\u003e\u003e(res)?;\n    };\n}\n\n#[macro_export]\nmacro_rules! get_line {\n    ($ret:ident, $lines:ident) =\u003e {\n        let $ret = $lines.next().unwrap_or_else(|| {\n            Err(std::io::Error::new(\n                std::io::ErrorKind::UnexpectedEof,\n                \"Unexpected EOF!\",\n            ))\n        })?;\n    };\n}\n\n#[macro_export]\nmacro_rules! get_line_parse {\n    ($lines:ident, $ret:ident, $exp:expr) =\u003e {\n        $crate::get_line!(line, $lines);\n        let (res, $ret) = $exp(\u0026line)?;\n        eof::\u003c$crate::parser::Input\u003c'_\u003e, $crate::parser::ParseError\u003c'_\u003e\u003e(res)?;\n    };\n}\n\n#[macro_export]\nmacro_rules! get_line_recognize {\n    ($lines:ident, $exp:expr) =\u003e {\n        $crate::get_line!(line, $lines);\n        let (res, _) = $exp(\u0026line)?;\n        eof::\u003c$crate::parser::Input\u003c'_\u003e, $crate::parser::ParseError\u003c'_\u003e\u003e(res)?;\n    };\n}\n","traces":[{"line":26,"address":[6361359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[6362327,6362040,6362113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1004960,1005120,1005200,1004880,1005040,1004800,1004720,1004640],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cstd::io::buffered::bufreader::BufReader\u003c\u0026[u8]\u003e\u003e"},{"line":341,"address":[1004978,1005058,1004738,1004898,1005218,1004818,1004658,1005138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1004973,1004813,1005133,1004653,1004733,1005053,1004893,1005213],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","__w","dqg","dqg","src","encoding","encoding_dict.rs"],"content":"use std::collections::HashMap;\n\nuse custom_debug_derive::Debug;\nuse kissat_rs::Literal;\n\nuse crate::graph::VertexIndex;\n\nconst MAX_LITERAL: Literal = 2i32.pow(28) - 1;\n\n#[derive(Debug)]\npub struct SATEncodingDictionary {\n    literal_counter: Literal,\n    #[debug(skip)]\n    literal_map: HashMap\u003ci64, Literal\u003e,\n}\n\nimpl Default for SATEncodingDictionary {\n    fn default() -\u003e Self {\n        SATEncodingDictionary {\n            literal_counter: 1,\n            literal_map: HashMap::new(),\n        }\n    }\n}\n\nimpl SATEncodingDictionary {\n    /// Lookup the literal to which an orbit/vertex pair is mapped.\n    pub fn lookup_pairing(\u0026mut self, orbit: Literal, vertex: Literal) -\u003e Literal {\n        let pairing_result = Self::pairing(orbit, vertex);\n\n        if let Some(literal) = self.literal_map.get(\u0026pairing_result) {\n            *literal\n        } else {\n            let literal = self.get_new_literal();\n            self.literal_map.insert(pairing_result, literal);\n            literal\n        }\n    }\n\n    fn pairing(orbit: VertexIndex, vertex: VertexIndex) -\u003e i64 {\n        let orbit_part = (orbit as i64) \u003c\u003c 32;\n        orbit_part + (vertex as i64)\n    }\n\n    fn unpair(pairing: i64) -\u003e (VertexIndex, VertexIndex) {\n        let orbit = pairing \u003e\u003e 32;\n        let vertex = pairing as i32;\n        (orbit as i32, vertex)\n    }\n\n    fn get_new_literal(\u0026mut self) -\u003e Literal {\n        let new_literal = self.literal_counter;\n\n        // Kissat doesn't allow variables over 2^28-1.\n        debug_assert!(new_literal \u003c MAX_LITERAL);\n\n        self.literal_counter += 1;\n        new_literal\n    }\n\n    pub fn variable_number(\u0026self) -\u003e usize {\n        self.literal_counter as usize\n    }\n\n    pub fn destroy(mut self) -\u003e Vec\u003c(VertexIndex, VertexIndex)\u003e {\n        let mut pairs = vec![(-1, -1); self.literal_counter as usize];\n        for (pairing, literal) in self.literal_map.drain() {\n            pairs[literal as usize] = Self::unpair(pairing);\n        }\n        pairs\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_pair() {\n        let orbit = 0x12345678;\n        let vertex = 0x07654321;\n        let pair = SATEncodingDictionary::pairing(orbit, vertex);\n        assert_eq!(0x1234567807654321, pair);\n    }\n\n    #[test]\n    fn test_unpair() {\n        let (orbit, vertex) = SATEncodingDictionary::unpair(0x1234567801234567);\n        assert_eq!(0x12345678, orbit);\n        assert_eq!(0x01234567, vertex);\n    }\n}\n","traces":[{"line":18,"address":[1575008],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":21,"address":[1575022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1575072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1575115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1575187,1575130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1575181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1575194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1575214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[1575228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1575248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1575260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1575272,1575298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1575328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1575336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1575348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1575352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1575376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[1575390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1575405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[1575445,1575482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1575520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1575525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1575991,1575536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1575558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1575648,1575986,1575702],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[1575941,1575852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[1575877],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":27},{"path":["/","__w","dqg","dqg","src","encoding","high_level.rs"],"content":"use itertools::Itertools;\n\nuse crate::{\n    graph::{Graph, VertexIndex},\n    quotient::{Orbits, QuotientGraph},\n};\n\n/// Trait that defines whether a type can be encoded\n/// into a high level view of a SAT formula.\npub trait HighLevelEncoding {\n    type HighLevelRepresentation;\n    fn encode_high(\u0026self) -\u003e Self::HighLevelRepresentation;\n}\n\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\npub struct EdgeEncoding(pub VertexIndex, pub VertexIndex);\n\nimpl EdgeEncoding {\n    pub fn get_edge(\u0026self) -\u003e (VertexIndex, VertexIndex) {\n        (self.0, self.1)\n    }\n}\n\nimpl HighLevelEncoding for Graph {\n    type HighLevelRepresentation = Vec\u003cEdgeEncoding\u003e;\n\n    fn encode_high(\u0026self) -\u003e Self::HighLevelRepresentation {\n        self.iterate_edges()\n            .map(|(start, end)| EdgeEncoding(start, end))\n            .collect()\n    }\n}\n\npub type OrbitEncoding = (VertexIndex, Vec\u003cVertexIndex\u003e);\n\nimpl HighLevelEncoding for Orbits {\n    type HighLevelRepresentation = Vec\u003cOrbitEncoding\u003e;\n\n    fn encode_high(\u0026self) -\u003e Self::HighLevelRepresentation {\n        self.iter()\n            .enumerate()\n            .filter(|(_, orbit)| *orbit \u003e= \u00260)\n            .sorted_by(|(_, orbit_a), (_, orbit_b)| orbit_a.cmp(orbit_b))\n            .chunk_by(|(_, orbit)| **orbit)\n            .into_iter()\n            .map(|(orbit_number, vertices)| {\n                (\n                    orbit_number,\n                    vertices\n                        .into_iter()\n                        .map(|(vertex, _)| vertex as VertexIndex)\n                        .collect(),\n                )\n            })\n            .collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct QuotientGraphEncoding(pub Vec\u003cEdgeEncoding\u003e, pub Vec\u003cOrbitEncoding\u003e);\n\nimpl HighLevelEncoding for QuotientGraph {\n    type HighLevelRepresentation = QuotientGraphEncoding;\n\n    fn encode_high(\u0026self) -\u003e Self::HighLevelRepresentation {\n        QuotientGraphEncoding(self.quotient_graph.encode_high(), self.orbits.encode_high())\n    }\n}\n","traces":[{"line":19,"address":[1412272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1412277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1302688],"length":1,"stats":{"Line":1},"fn_name":"encode_high"},{"line":28,"address":[1302712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1500032,1500045],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":39,"address":[1275856,1276107],"length":1,"stats":{"Line":1},"fn_name":"encode_high"},{"line":40,"address":[1275894,1276057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1500080,1500107],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":43,"address":[1500144,1500187],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":44,"address":[1500234,1500224],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":46,"address":[1500281,1500256],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":49,"address":[1500330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1500432,1500447],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":65,"address":[1275719,1275568],"length":1,"stats":{"Line":1},"fn_name":"encode_high"},{"line":66,"address":[1275597],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":15},{"path":["/","__w","dqg","dqg","src","encoding","low_level.rs"],"content":"use crate::graph::Graph;\n\nuse super::{\n    encoding_dict::SATEncodingDictionary,\n    high_level::{EdgeEncoding, OrbitEncoding, QuotientGraphEncoding},\n    Formula,\n};\n\npub trait SATEncoding {\n    fn encode_sat(\u0026self, dict: \u0026mut SATEncodingDictionary, original_graph: \u0026Graph) -\u003e Formula;\n}\n\nimpl SATEncoding for OrbitEncoding {\n    fn encode_sat(\u0026self, dict: \u0026mut SATEncodingDictionary, _original_graph: \u0026Graph) -\u003e Formula {\n        // This is actually the encoding that a valid transversal\n        // can only choose one element from the orbit.\n\n        // Encode the EO problem\n        // Possible encodings:\n        // - pairwise: (x1 || x2 || ... || xn) \u0026\u0026 for all i,j (~xi || ~xj), size = (n^2-n)/2\n        // - bitwise: with aux vars, size = n*ceil(ld n), ceil(ld n) aux vars\n        // - ladder: however this works, 3(n-1) binary clauses, n-1 ternary clauses, n-1 aux vars\n        // - matrix: how the heck does this even, 2*sqrt(n) aux vars, 1 n-ary clause, 1 sqrt(n)-ary clause, 1 n/sqrt(n)-ary clause, 2n+4*sqrt(n)+O(fourth root n) binary clauses\n\n        // For now we use pairwise encoding, because it's easy to implement\n        // Disjunction of all vertex-in-orbit pairs to encode AT LEAST ONE\n        // ---------------------------------------------------------------\n        // \\/ vi for all vi in the orbit\n        let (orbit, orbit_elements) = self;\n        let mut orbit_element_encodings = Vec::with_capacity(orbit_elements.len());\n\n        for orbit_element in orbit_elements {\n            orbit_element_encodings.push(dict.lookup_pairing(*orbit, *orbit_element));\n        }\n\n        vec![orbit_element_encodings]\n    }\n}\n\nimpl SATEncoding for QuotientGraphEncoding {\n    fn encode_sat(\u0026self, dict: \u0026mut SATEncodingDictionary, original_graph: \u0026Graph) -\u003e Formula {\n        // This is actually the encoding that edges between two\n        // vertices (i.e. two orbits) of a quotient graph is preserved\n        // when the transversal chooses two vertices from the orbits.\n        let QuotientGraphEncoding(quotient_edges, orbits) = self;\n        let mut formula = Vec::new();\n\n        // for all (o1,o2) edges in the quotient graph G\\O (i.e. o1, o2 in O)\n        for (start_orbit, end_orbit) in quotient_edges.iter().map(EdgeEncoding::get_edge) {\n            let start_orbit_elements = {\n                let index = orbits.binary_search_by(|(orbit,_)| orbit.cmp(\u0026start_orbit)) .expect(\n                    \"The edges were computed from the orbits, how can there be no fitting orbit?\",\n                );\n                \u0026orbits[index].1\n            };\n            let end_orbit_elements =\n                {\n                    let index = orbits.binary_search_by(|(orbit,_)| orbit.cmp(\u0026end_orbit)) .expect(\n                    \"The edges were computed from the orbits, how can there be no fitting orbit?\",\n                );\n                    \u0026orbits[index].1\n                };\n\n            // for all vertices v1 in o1\n            for start_orbit_element in start_orbit_elements {\n                // for all vertices v2 in o2\n                'end: for end_orbit_element in end_orbit_elements {\n                    // If the edge (v1,v2) for the two picked vertices exists\n                    // in the original graph, we do not need to encode it.\n                    if original_graph.lookup_edge(start_orbit_element, end_orbit_element) {\n                        continue 'end;\n                    }\n\n                    let start_orbit_relation =\n                        dict.lookup_pairing(start_orbit, *start_orbit_element);\n                    let end_orbit_relation = dict.lookup_pairing(end_orbit, *end_orbit_element);\n\n                    // If there is an edge in the quotient graph,\n                    // the transversal needs to pick vertices from\n                    // the related orbits that are also connected in G.\n                    // We don't actually need to encode this for existing edges\n                    // in G but only for non-existing ones. We also don't need\n                    // the edge in the quotient graph, as it also exists.\n                    // ------------------------------------------------\n                    // (o1,o2) \u0026\u0026 (o1, v1) \u0026\u0026 (o2,v2) =\u003e False\n                    // ~(o1, v1) || ~(o2,v2)\n                    let clause = vec![-start_orbit_relation, -end_orbit_relation];\n                    formula.push(clause);\n                }\n            }\n        }\n\n        formula\n    }\n}\n","traces":[{"line":14,"address":[1276144,1276660,1276689],"length":1,"stats":{"Line":1},"fn_name":"encode_sat"},{"line":29,"address":[1276203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1276236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1276271,1276339,1276444],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[1276460,1276648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[1276483,1276422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1413920,1412304],"length":1,"stats":{"Line":1},"fn_name":"encode_sat"},{"line":45,"address":[1412375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1412411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1412424,1412503,1412739],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[653312,653339],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":54,"address":[1412927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[653360,653387],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":61,"address":[1413145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1413200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1413339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1413486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1413520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[1413564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1413605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1413908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1412688],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","__w","dqg","dqg","src","encoding","mod.rs"],"content":"//! This file contains the high and low level encodings\n//! needed to encode the descriptive quotient problem\n//! as a CNF formula which can then be decided by a SAT solver.\n\nuse kissat_rs::Literal;\n\nmod encoding_dict;\npub use encoding_dict::SATEncodingDictionary;\n\nmod high_level;\npub use high_level::{EdgeEncoding, HighLevelEncoding, OrbitEncoding, QuotientGraphEncoding};\n\nmod low_level;\npub use low_level::SATEncoding;\n\nuse crate::{graph::Graph, quotient::QuotientGraph};\n\npub type Clause = Vec\u003cLiteral\u003e;\npub type Formula = Vec\u003cClause\u003e;\n\n/// Encode the decision problem whether a set of generators\n/// induces a descriptive quotient graph into SAT.\n#[allow(clippy::needless_collect)]\npub fn encode_problem(\n    quotient_graph: \u0026QuotientGraph,\n    original_graph: \u0026Graph,\n) -\u003e Option\u003c(impl Iterator\u003cItem = Clause\u003e, SATEncodingDictionary)\u003e {\n    let mut dict = SATEncodingDictionary::default();\n\n    let QuotientGraphEncoding(quotient_edges, orbits) = quotient_graph.encode_high();\n\n    let transversal_encoding = orbits\n        .iter()\n        .flat_map(|orbit| orbit.encode_sat(\u0026mut dict, original_graph))\n        .collect::\u003cFormula\u003e();\n\n    let descriptive_constraint_encoding =\n        QuotientGraphEncoding(quotient_edges, orbits).encode_sat(\u0026mut dict, original_graph);\n\n    if descriptive_constraint_encoding.is_empty() {\n        None\n    } else {\n        Some((\n            transversal_encoding\n                .into_iter()\n                .chain(descriptive_constraint_encoding),\n            dict,\n        ))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::{encoding::high_level::EdgeEncoding, graph::GraphError, Error};\n\n    use super::*;\n\n    #[test]\n    fn test_encode_problem_trivial() -\u003e Result\u003c(), GraphError\u003e {\n        // 0 -- 1 -- 2 where 0 and 2 are in the same orbit\n        let mut graph = Graph::new_ordered(3);\n        graph.add_arc(0, 1)?;\n        graph.add_arc(2, 1)?;\n        let orbits = vec![0, 1, 0];\n        let quotient_graph = QuotientGraph::from_graph_orbits(\u0026graph, orbits);\n\n        let formula = encode_problem(\u0026quotient_graph, \u0026graph);\n        assert!(formula.is_none());\n        Ok(())\n    }\n\n    #[test]\n    fn test_encode_problem_nontrivial() -\u003e Result\u003c(), GraphError\u003e {\n        //0-1-2-3, where 1 and 2 are in the same (fake) orbit.\n        let mut graph = Graph::new_ordered(4);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(2, 3)?;\n        let colors = vec![1, 2, 2, 3];\n        graph.set_colours(\u0026colors)?;\n\n        // Not the actual orbits, but used to check for non-descriptiveness.\n        let fake_orbits = vec![0, 1, 1, 3];\n        let quotient = QuotientGraph::from_graph_orbits(\u0026graph, fake_orbits);\n\n        let expected: Formula = vec![\n            // vertex 0 in orbit 0\n            vec![1],\n            // Exactly one of 1,2 in orbit 1\n            vec![2, 3],\n            // vertex 3 in orbit 3\n            vec![4],\n            // can't pick both 0 in 0 and 2 in 1\n            vec![-1, -3],\n            // can't pick both 2 in 1 and 0 in 0\n            vec![-3, -1],\n            // can't pick both 1 in 1 and 3 in 3\n            vec![-2, -4],\n            // can't pick both 3 in 3 and 1 in 1\n            vec![-4, -2],\n        ];\n\n        let formula = encode_problem(\u0026quotient, \u0026graph);\n        assert!(formula.is_some());\n        assert!(formula\n            .unwrap()\n            .0\n            .zip(expected.into_iter())\n            .all(|(fst, snd)| fst == snd));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_encode_graph_edges() -\u003e Result\u003c(), Error\u003e {\n        let mut graph = Graph::new_ordered(5);\n        graph.add_arc(0, 1)?;\n        graph.add_arc(1, 2)?;\n        graph.add_arc(3, 4)?;\n        graph.add_arc(4, 0)?;\n\n        assert_eq!(true, graph.lookup_edge(\u00260, \u00261));\n        assert_eq!(true, graph.lookup_edge(\u00261, \u00262));\n        assert_eq!(true, graph.lookup_edge(\u00263, \u00264));\n        assert_eq!(true, graph.lookup_edge(\u00264, \u00260));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_descriptive_constraint() {\n        let orbit_encoding = vec![(0, vec![0, 1]), (2, vec![2, 3])];\n        let edge_encoding = vec![EdgeEncoding(0, 2)];\n        let mut dict = SATEncodingDictionary::default();\n        let some_graph = Graph::new_ordered(4);\n\n        let o0v0 = dict.lookup_pairing(0, 0);\n        let o0v1 = dict.lookup_pairing(0, 1);\n        let o2v2 = dict.lookup_pairing(2, 2);\n        let o2v3 = dict.lookup_pairing(2, 3);\n\n        let constraint02 = vec![-o0v0, -o2v2];\n        let constraint03 = vec![-o0v0, -o2v3];\n        let constraint12 = vec![-o0v1, -o2v2];\n        let constraint13 = vec![-o0v1, -o2v3];\n\n        let formula =\n            QuotientGraphEncoding(edge_encoding, orbit_encoding).encode_sat(\u0026mut dict, \u0026some_graph);\n        assert_eq!(4, formula.len());\n        assert!(formula.contains(\u0026constraint02));\n        assert!(formula.contains(\u0026constraint03));\n        assert!(formula.contains(\u0026constraint12));\n        assert!(formula.contains(\u0026constraint13));\n    }\n\n    #[test]\n    fn test_transversal_encoding() {\n        let orbit_encoding = (0, vec![0, 1, 4]);\n        let mut dict = SATEncodingDictionary::default();\n        let some_graph = Graph::new_ordered(0);\n        let pick0 = dict.lookup_pairing(0, 0);\n        let pick1 = dict.lookup_pairing(0, 1);\n        let pick4 = dict.lookup_pairing(0, 4);\n        assert_eq!(1, pick0);\n        assert_eq!(2, pick1);\n        assert_eq!(3, pick4);\n\n        let at_least_one = vec![vec![pick0, pick1, pick4]];\n\n        let formula = orbit_encoding.encode_sat(\u0026mut dict, \u0026some_graph);\n        assert_eq!(1, formula.len());\n        assert_eq!(at_least_one, formula);\n    }\n\n    #[test]\n    fn test_encode_graph() {\n        let mut graph = Graph::new_ordered(4);\n        graph.add_arc(0, 1).unwrap();\n        graph.add_arc(1, 2).unwrap();\n        graph.add_arc(2, 3).unwrap();\n        graph.add_arc(3, 1).unwrap();\n        let encoded = graph.encode_high();\n        assert_eq!(\n            encoded,\n            vec![\n                EdgeEncoding(0, 1),\n                EdgeEncoding(1, 2),\n                EdgeEncoding(2, 3),\n                EdgeEncoding(3, 1)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_encode_orbits() {\n        let orbits = vec![0, 1, 2, 0, 2, 1, 0];\n        let encoded = orbits.encode_high();\n        assert_eq!(\n            encoded,\n            vec![(0, vec![0, 3, 6]), (1, vec![1, 5]), (2, vec![2, 4])]\n        );\n    }\n}\n","traces":[{"line":24,"address":[1285424,1286609,1286684],"length":1,"stats":{"Line":1},"fn_name":"encode_problem"},{"line":28,"address":[1285459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1285530,1285578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1285787,1285666,1285734],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[938755,938720],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":37,"address":[1285849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1286138,1286235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1286227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1286342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1286159,1286304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[1286240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1286311],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","__w","dqg","dqg","src","evaluate.rs"],"content":"//! Log evaluation mode that allows to\n//! evaluate the logs of the quotientPlanning\n//! tool run as experiments.\n\nuse std::{\n    cmp::Ordering,\n    fmt::Display,\n    io::{BufRead, Lines},\n    iter::Peekable,\n    str::FromStr,\n};\n\nuse crate::{\n    parser::{Input, ParseError},\n    MetricUsed,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Copy)]\npub enum PlanResult {\n    ValidPlan(usize),\n    NotSolved,\n}\n\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\npub enum QuotientResult {\n    QuotientConcretePlans(PlanResult, PlanResult),\n    NoActionSymmetry,\n    Nondescriptive,\n    TimedOut,\n}\n\n#[derive(Debug, Default, PartialEq)]\nstruct ToolStats {\n    search_time: f64,\n    translation_time: f64,\n    quotient_search_time: f64,\n    quotient_translation_time: f64,\n    symm_det_time: f64,\n    colouring_time: f64,\n    inst_find_time: f64,\n}\n\nimpl Display for ToolStats {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{:.6} {:.6} {:.6} {:.6} {:.6} {:.6} {:.6}\",\n            self.search_time,\n            self.translation_time,\n            self.quotient_search_time,\n            self.quotient_translation_time,\n            self.symm_det_time,\n            self.colouring_time,\n            self.inst_find_time\n        )\n    }\n}\n\n#[derive(Debug)]\npub struct Log {\n    metric: MetricUsed,\n    default_result: PlanResult,\n    quotient_result: QuotientResult,\n    tool_stats: ToolStats,\n}\n\nimpl PartialEq for Log {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.metric == other.metric\n            \u0026\u0026 self.default_result == other.default_result\n            \u0026\u0026 self.quotient_result == other.quotient_result\n    }\n}\n\nimpl Eq for Log {}\n\nfn evaluate_plan_result\u003c'a\u003e(line: Input\u003c'a\u003e) -\u003e Option\u003cPlanResult\u003e {\n    use nom::{\n        branch::alt, bytes::complete::tag, character::complete::digit1, combinator::map,\n        sequence::preceded,\n    };\n    let valid_tag =\n        tag::\u003cInput\u003c'a\u003e, Input\u003c'a\u003e, ParseError\u003c'a\u003e\u003e(\"Plan is valid and it is of length \");\n    let valid_parser = map(preceded(valid_tag, digit1), |length: \u0026str| {\n        PlanResult::ValidPlan(length.parse().unwrap())\n    });\n    let not_solved_parser = map(\n        tag(\"The problem was not solved! Plan can't be valid!\"),\n        |_| PlanResult::NotSolved,\n    );\n    alt((valid_parser, not_solved_parser))(line)\n        .ok()\n        .map(|(_, plan_result)| plan_result)\n}\n\nfn evaluate_tool_stats\u003c'a\u003e(line: \u0026'a str) -\u003e Option\u003cToolStats\u003e {\n    use nom::{\n        character::complete::{char, i32, multispace0},\n        combinator::recognize,\n        multi::many_m_n,\n        sequence::{preceded, terminated, tuple},\n    };\n\n    let int_parser =\n        terminated::\u003cInput\u003c'a\u003e, i32, Input\u003c'a\u003e, ParseError\u003c'a\u003e, _, _\u003e(i32, multispace0);\n    let float_parser = terminated(recognize(tuple((i32, char('.'), i32))), multispace0);\n    let uninteresting_parser = many_m_n(11, 11, int_parser);\n    let interesting_parser = many_m_n(7, 7, float_parser);\n\n    preceded(uninteresting_parser, interesting_parser)(line)\n        .ok()\n        .map(|(_, times)| ToolStats {\n            search_time: times[0].parse().unwrap(),\n            translation_time: times[1].parse().unwrap(),\n            quotient_search_time: times[2].parse().unwrap(),\n            quotient_translation_time: times[3].parse().unwrap(),\n            symm_det_time: times[4].parse().unwrap(),\n            colouring_time: times[5].parse().unwrap(),\n            inst_find_time: times[6].parse().unwrap(),\n        })\n}\n\nfn evaluate_log\u003cB: BufRead\u003e(peekable: \u0026mut Peekable\u003c\u0026mut Lines\u003cB\u003e\u003e) -\u003e Option\u003cLog\u003e {\n    let metric = peekable.find_map(|line| {\n        line.unwrap()\n            .strip_suffix(':')\n            .and_then(|line| MetricUsed::from_str(line).ok())\n    })?;\n    let tool_stats = peekable\n        .next()\n        .and_then(|line| evaluate_tool_stats(line.as_ref().unwrap()))\n        .unwrap_or_default();\n    let default_result = peekable.find_map(|line| evaluate_plan_result(line.unwrap().as_str()))?;\n\n    let mut quotient_result = QuotientResult::TimedOut;\n    let mut quotient_next = false;\n\n    loop {\n        if peekable\n            .next_if(|line| line.as_ref().unwrap() == \"No symmetries found, exiting!!\")\n            .is_some()\n        {\n            quotient_result = QuotientResult::NoActionSymmetry;\n            break;\n        } else if peekable\n            .next_if(|line| line.as_ref().unwrap() == \"No covering instantiations, exiting!!\")\n            .is_some()\n        {\n            quotient_result = QuotientResult::Nondescriptive;\n            break;\n        } else if peekable\n            .next_if(|line| line.as_ref().unwrap() == \"Quotient problem plan:\")\n            .is_some()\n        {\n            quotient_result =\n                QuotientResult::QuotientConcretePlans(PlanResult::NotSolved, PlanResult::NotSolved);\n            quotient_next = true;\n        } else if peekable\n            .next_if(|line| line.as_ref().unwrap() == \"Concrete problem plan:\")\n            .is_some()\n        {\n            quotient_next = false;\n        } else if peekable\n            .peek()?\n            .as_ref()\n            .unwrap()\n            .strip_suffix(':')\n            .and_then(|line| MetricUsed::from_str(line).ok())\n            .is_some()\n        {\n            quotient_result = QuotientResult::TimedOut;\n            break;\n        } else if let Some(plan_result) =\n            evaluate_plan_result(peekable.peek().unwrap().as_ref().unwrap().as_str())\n        {\n            if quotient_next {\n                quotient_result =\n                    QuotientResult::QuotientConcretePlans(plan_result, PlanResult::NotSolved);\n                peekable.next();\n                if matches!(plan_result, PlanResult::NotSolved) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if let QuotientResult::QuotientConcretePlans(quotient, _) = quotient_result {\n                quotient_result = QuotientResult::QuotientConcretePlans(quotient, plan_result);\n                peekable.next();\n                break;\n            }\n            unreachable!();\n        } else {\n            peekable.next();\n        }\n    }\n\n    Some(Log {\n        metric,\n        default_result,\n        quotient_result,\n        tool_stats,\n    })\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn evaluate_log_file\u003cB: BufRead\u003e(file_as_lines: \u0026mut Lines\u003cB\u003e) -\u003e Vec\u003cLog\u003e {\n    let mut logs = Vec::new();\n    let mut peekable = file_as_lines.peekable();\n\n    while let Some(log) = evaluate_log(\u0026mut peekable) {\n        logs.push(log);\n    }\n\n    logs\n}\n\n#[cfg(not(tarpaulin_include))]\nfn compare_results(baseline: \u0026PlanResult, result: \u0026QuotientResult) -\u003e Ordering {\n    use std::cmp::Ordering::*;\n\n    if let PlanResult::ValidPlan(base) = baseline {\n        if let QuotientResult::QuotientConcretePlans(_, result) = result {\n            match result {\n                PlanResult::ValidPlan(result) =\u003e base.cmp(result),\n                PlanResult::NotSolved =\u003e Less,\n            }\n        } else {\n            Less\n        }\n    } else if let QuotientResult::QuotientConcretePlans(_, result) = result {\n        if matches!(result, PlanResult::ValidPlan(_)) {\n            Greater\n        } else {\n            Equal\n        }\n    } else {\n        Equal\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn print_eval_results(\n    baseline: \u0026PlanResult,\n    standard: \u0026QuotientResult,\n    standard_result: \u0026Ordering,\n    result: Option\u003c(QuotientResult, ToolStats)\u003e,\n    name: \u0026str,\n) {\n    if let Some((result, stats)) = result {\n        let other_result = compare_results(baseline, \u0026result);\n        match other_result.cmp(standard_result) {\n            Ordering::Greater =\u003e println!(\"Success! {:?} for {}: {}\", result, name, stats),\n            Ordering::Equal =\u003e {\n                if let QuotientResult::QuotientConcretePlans(_, PlanResult::ValidPlan(n)) = standard\n                {\n                    if let QuotientResult::QuotientConcretePlans(_, PlanResult::ValidPlan(m)) =\n                        result\n                    {\n                        if *n \u003e m {\n                            println!(\"Success! {:?} for {}: {}\", result, name, stats);\n                            return;\n                        }\n                    }\n                }\n\n                println!(\"No failure! {:?} for {}: {}\", result, name, stats);\n            }\n            Ordering::Less =\u003e {\n                println!(\"Failure! {:?} for {}: {}\", result, name, stats);\n            }\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn evaluate_logs(logs: Vec\u003cLog\u003e) {\n    let mut baseline = None;\n    let mut standard = None;\n    let mut least = None;\n    let mut biggest = None;\n    let mut sparse = None;\n\n    for log in logs {\n        match log.metric {\n            MetricUsed::LeastOrbits =\u003e least = Some((log.quotient_result, log.tool_stats)),\n            MetricUsed::BiggestOrbits =\u003e biggest = Some((log.quotient_result, log.tool_stats)),\n            MetricUsed::Sparsity =\u003e sparse = Some((log.quotient_result, log.tool_stats)),\n            MetricUsed::Standard =\u003e {\n                standard = Some((log.quotient_result, log.tool_stats));\n                baseline = Some(log.default_result);\n            }\n        }\n    }\n\n    if let Some(baseline) = baseline {\n        if let Some(standard) = standard {\n            let standard_result = compare_results(\u0026baseline, \u0026standard.0);\n            println!(\n                \"Baseline: {:?} Standard: {:?}, {}\",\n                baseline, standard.0, standard.1\n            );\n\n            print_eval_results(\u0026baseline, \u0026standard.0, \u0026standard_result, least, \"Least\");\n            print_eval_results(\u0026baseline, \u0026standard.0, \u0026standard_result, biggest, \"Biggest\");\n            print_eval_results(\u0026baseline, \u0026standard.0, \u0026standard_result, sparse, \"Sparse\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::io::Cursor;\n\n    use super::*;\n\n    const TEST_STATS: ToolStats = ToolStats {\n        search_time: 4.101270,\n        translation_time: 25.530000,\n        quotient_search_time: -1.000000,\n        quotient_translation_time: 23.060000,\n        symm_det_time: 12.913098,\n        colouring_time: 0.000000,\n        inst_find_time: 0.010000,\n    };\n\n    #[test]\n    fn test_evaluate_plan_result() {\n        let plan_result1 = \"Plan is valid and it is of length 36\";\n        assert_eq!(\n            Some(PlanResult::ValidPlan(36)),\n            evaluate_plan_result(plan_result1),\n        );\n\n        let plan_result2 = \"The problem was not solved! Plan can't be valid!\";\n        assert_eq!(\n            Some(PlanResult::NotSolved),\n            evaluate_plan_result(plan_result2),\n        );\n\n        let plan_result3 = \"Covering instantiation set size is: 2\";\n        assert_eq!(None, evaluate_plan_result(plan_result3));\n    }\n\n    #[test]\n    fn test_evaluate_tool_stats() {\n        let tool_stats = \"6464 4482 418 400 109151 -1 10261 -1 98 1 0 4.101270 25.530000 -1.000000 23.060000 12.913098 0.000000 0.010000\";\n        assert_eq!(Some(TEST_STATS), evaluate_tool_stats(tool_stats));\n    }\n\n    #[test]\n    fn test_evaluate_log_nondescriptive() {\n        let raw = \"standard:\n6464 4482 418 400 109151 -1 10261 -1 98 1 0 4.101270 25.530000 -1.000000 23.060000 12.913098 0.000000 0.010000\nThe causal graph is not acyclic.\n51 variables of 51 necessary\nPlan is valid and it is of length 36\nInitial size of primary cover 9.\nInitial size of secondary cover 432.\nNumber of variable orbits is 0\nNumber of actions = 3114\nNumber of variables = 432\nPrinting action edges\nPrinting variable edges (only to variables)\nPrinting initial state edges\nPrinting goal edges\nNumber of action orbits = 918\nNumber of variable orbits = 179\nNumber of actions in the problem = 3114\nNumber of action orbits added to the quotient problem = 918\nNumber of var in the problem initial state = 51\nNumber of var orbits added to the quotient problem initial state = 31\nNumber of var in the problem goal state = 9\nNumber of var orbits added to the quotient problem goal state = 3\nPrimary cover size: 9\nNo covering instantiations, exiting!!\";\n        let mut lines = Cursor::new(raw).lines();\n        let mut peekable = (\u0026mut lines).peekable();\n        let log = evaluate_log(\u0026mut peekable);\n        let expected_log = Some(Log {\n            metric: MetricUsed::Standard,\n            default_result: PlanResult::ValidPlan(36),\n            quotient_result: QuotientResult::Nondescriptive,\n            tool_stats: TEST_STATS,\n        });\n        assert_eq!(expected_log, log);\n    }\n\n    #[test]\n    fn test_evaluate_log_nosymmetry() {\n        let raw = \"biggest_orbit:\n6464 4482 418 400 109151 -1 10261 -1 98 1 0 4.101270 25.530000 -1.000000 23.060000 12.913098 0.000000 0.010000\nThe causal graph is not acyclic.\n\n23 variables of 23 necessary\n\nCurrent action is 34\nCurrent action is 77\nCurrent action is 88\nCurrent action is 93\nCurrent action is 55\nPlan is valid and it is of length 5\nInitial size of primary cover 2.\nInitial size of secondary cover 66.\nNumber of variable orbits is 0\nNumber of actions = 104\nNumber of variables = 66\n\nPrinting action edges\n\nPrinting variable edges (only to variables)\n\nPrinting initial state edges\n\nPrinting goal edges\n\nNumber of action orbits = 104\nNumber of variable orbits = 66\nNumber of actions in the problem = 104\nNumber of action orbits added to the quotient problem = 104\nNumber of var in the problem initial state = 23\nNumber of var orbits added to the quotient problem initial state = 23\nNumber of var in the problem goal state = 2\nNumber of var orbits added to the quotient problem goal state = 2\nNo symmetries found, exiting!!\";\n        let mut lines = Cursor::new(raw).lines();\n        let mut peekable = (\u0026mut lines).peekable();\n        let log = evaluate_log(\u0026mut peekable);\n        let expected_log = Some(Log {\n            metric: MetricUsed::BiggestOrbits,\n            default_result: PlanResult::ValidPlan(5),\n            quotient_result: QuotientResult::NoActionSymmetry,\n            tool_stats: TEST_STATS,\n        });\n        assert_eq!(expected_log, log);\n    }\n\n    #[test]\n    fn test_evaluate_log_quotient_notsolved() {\n        let raw = \"least_orbits:\n6464 4482 418 400 109151 -1 10261 -1 98 1 0 4.101270 25.530000 -1.000000 23.060000 12.913098 0.000000 0.010000\nThe causal graph is not acyclic.\n408 variables of 408 necessary\nPlan is valid and it is of length 194\nInitial size of primary cover 15.\nInitial size of secondary cover 849.\nNumber of variable orbits is 0\nNumber of actions = 2814\nNumber of variables = 849\nPrinting action edges\nPrinting variable edges (only to variables)\nPrinting initial state edges\nPrinting goal edges\nNumber of action orbits = 2474\nNumber of variable orbits = 749\nNumber of actions in the problem = 2814\nNumber of action orbits added to the quotient problem = 2474\nNumber of var in the problem initial state = 408\nNumber of var orbits added to the quotient problem initial state = 360\nNumber of var in the problem goal state = 15\nNumber of var orbits added to the quotient problem goal state = 13\nPrimary cover size: 15\nPrimary cover size: 2\nPrimary cover size: 1\nCovering instantiation set size is: 3\nThe number of common resources is 749 and the size of common resource orbits is 749\nAdding orbit 0 to the quotient goal\nAdding orbit 720 to the quotient goal\nQuotient problem plan:\nThe problem was not solved! Plan can't be valid!\nConcrete problem plan:\nPlan is valid and it is of length 36\";\n        let mut lines = Cursor::new(raw).lines();\n        let mut peekable = (\u0026mut lines).peekable();\n        let log = evaluate_log(\u0026mut peekable);\n        let expected_log = Some(Log {\n            metric: MetricUsed::LeastOrbits,\n            default_result: PlanResult::ValidPlan(194),\n            quotient_result: QuotientResult::QuotientConcretePlans(\n                PlanResult::NotSolved,\n                PlanResult::NotSolved,\n            ),\n            tool_stats: TEST_STATS,\n        });\n        assert_eq!(expected_log, log);\n    }\n\n    #[test]\n    fn test_evaluate_log_concrete_notsolved() {\n        let raw = \"least_orbits:\n6464 4482 418 400 109151 -1 10261 -1 98 1 0 4.101270 25.530000 -1.000000 23.060000 12.913098 0.000000 0.010000\nThe causal graph is not acyclic.\n408 variables of 408 necessary\nThe problem was not solved! Plan can't be valid!\nInitial size of primary cover 15.\nInitial size of secondary cover 849.\nNumber of variable orbits is 0\nNumber of actions = 2814\nNumber of variables = 849\nPrinting action edges\nPrinting variable edges (only to variables)\nPrinting initial state edges\nPrinting goal edges\nNumber of action orbits = 2474\nNumber of variable orbits = 749\nNumber of actions in the problem = 2814\nNumber of action orbits added to the quotient problem = 2474\nNumber of var in the problem initial state = 408\nNumber of var orbits added to the quotient problem initial state = 360\nNumber of var in the problem goal state = 15\nNumber of var orbits added to the quotient problem goal state = 13\nPrimary cover size: 15\nPrimary cover size: 2\nPrimary cover size: 1\nCovering instantiation set size is: 3\nThe number of common resources is 749 and the size of common resource orbits is 749\nAdding orbit 0 to the quotient goal\nAdding orbit 720 to the quotient goal\nQuotient problem plan:\nPlan is valid and it is of length 36\nConcrete problem plan:\nThe problem was not solved! Plan can't be valid!\";\n        let mut lines = Cursor::new(raw).lines();\n        let mut peekable = (\u0026mut lines).peekable();\n        let log = evaluate_log(\u0026mut peekable);\n        let expected_log = Some(Log {\n            metric: MetricUsed::LeastOrbits,\n            default_result: PlanResult::NotSolved,\n            quotient_result: QuotientResult::QuotientConcretePlans(\n                PlanResult::ValidPlan(36),\n                PlanResult::NotSolved,\n            ),\n            tool_stats: TEST_STATS,\n        });\n        assert_eq!(expected_log, log);\n    }\n\n    #[test]\n    fn test_evaluate_log_valid() {\n        let raw = \"sparsity:\n6464 4482 418 400 109151 -1 10261 -1 98 1 0 4.101270 25.530000 -1.000000 23.060000 12.913098 0.000000 0.010000\nThe causal graph is not acyclic.\n51 variables of 51 necessary\nPlan is valid and it is of length 36\nInitial size of primary cover 9.\nInitial size of secondary cover 432.\nNumber of variable orbits is 0\nNumber of actions = 3114\nNumber of variables = 432\nPrinting action edges\nPrinting variable edges (only to variables)\nPrinting initial state edges\nPrinting goal edges\nNumber of action orbits = 2772\nNumber of variable orbits = 404\nNumber of actions in the problem = 3114\nNumber of action orbits added to the quotient problem = 2772\nNumber of var in the problem initial state = 51\nNumber of var orbits added to the quotient problem initial state = 49\nNumber of var in the problem goal state = 9\nNumber of var orbits added to the quotient problem goal state = 9\nPrimary cover size: 9\nCovering instantiation set size is: 1\nThe number of common resources is 0 and the size of common resource orbits is 0\nCommon resources are Common resource orbits before removing non-preconditions are \nCommon resource orbits after removing non-preconditions are \n\nQuotient problem plan:\nPlan is valid and it is of length 48000\nConcrete problem plan:\nCurrent action is 1527\nCurrent action is 2502\nCurrent action is 993\nCurrent action is 2667\nCurrent action is 1170\nCurrent action is 2832\nCurrent action is 1344\nCurrent action is 2557\nCurrent action is 2034\nCurrent action is 495\nCurrent action is 1047\nCurrent action is 2612\nCurrent action is 2088\nCurrent action is 1101\nCurrent action is 2994\nCurrent action is 554\nCurrent action is 2700\nCurrent action is 1492\nCurrent action is 1162\nCurrent action is 1528\nCurrent action is 2722\nCurrent action is 1492\nCurrent action is 1220\nCurrent action is 1528\nCurrent action is 2777\nCurrent action is 1278\nCurrent action is 2874\nCurrent action is 1493\nCurrent action is 1336\nCurrent action is 1529\nCurrent action is 2887\nCurrent action is 1493\nCurrent action is 1400\nCurrent action is 1529\nCurrent action is 2942\nCurrent action is 1452\nPlan is valid and it is of length 12\";\n        let mut lines = Cursor::new(raw).lines();\n        let mut peekable = (\u0026mut lines).peekable();\n        let log = evaluate_log(\u0026mut peekable);\n        let expected_log = Some(Log {\n            metric: MetricUsed::Sparsity,\n            default_result: PlanResult::ValidPlan(36),\n            quotient_result: QuotientResult::QuotientConcretePlans(\n                PlanResult::ValidPlan(48000),\n                PlanResult::ValidPlan(12),\n            ),\n            tool_stats: TEST_STATS,\n        });\n        assert_eq!(expected_log, log);\n    }\n\n    #[test]\n    fn test_evaluate_log_concrete_timeout() {\n        let raw = \"least_orbits:\nThe causal graph is not acyclic.\n408 variables of 408 necessary\nThe problem was not solved! Plan can't be valid!\nInitial size of primary cover 15.\nInitial size of secondary cover 849.\nNumber of variable orbits is 0\nNumber of actions = 2814\nNumber of variables = 849\nPrinting action edges\nPrinting variable edges (only to variables)\nPrinting initial state edges\nPrinting goal edges\nNumber of action orbits = 2474\nNumber of variable orbits = 749\nNumber of actions in the problem = 2814\nNumber of action orbits added to the quotient problem = 2474\nNumber of var in the problem initial state = 408\nNumber of var orbits added to the quotient problem initial state = 360\nNumber of var in the problem goal state = 15\nNumber of var orbits added to the quotient problem goal state = 13\nPrimary cover size: 15\nPrimary cover size: 2\nPrimary cover size: 1\nCovering instantiation set size is: 3\nThe number of common resources is 749 and the size of common resource orbits is 749\nAdding orbit 0 to the quotient goal\nAdding orbit 720 to the quotient goal\nQuotient problem plan:\nPlan is valid and it is of length 36\n\nsparsity:\";\n        let mut lines = Cursor::new(raw).lines();\n        let mut peekable = (\u0026mut lines).peekable();\n        let log = evaluate_log(\u0026mut peekable);\n        let expected_log = Some(Log {\n            metric: MetricUsed::LeastOrbits,\n            default_result: PlanResult::NotSolved,\n            quotient_result: QuotientResult::TimedOut,\n            tool_stats: Default::default(),\n        });\n        assert_eq!(expected_log, log);\n    }\n}\n","traces":[{"line":44,"address":[1350704],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":45,"address":[1351126,1351910,1352374,1352142,1352838,1350799,1350964,1352606,1350909,1351019,1351074,1350854,1351446,1351678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1353152],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":69,"address":[1353175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1353208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1353228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1353264],"length":1,"stats":{"Line":1},"fn_name":"evaluate_plan_result"},{"line":82,"address":[1353297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1353336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[1255523,1255635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1353378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1255664,1255679],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":91,"address":[1353432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1255712],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":96,"address":[1353600],"length":1,"stats":{"Line":1},"fn_name":"evaluate_tool_stats"},{"line":104,"address":[1353643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1353648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1353696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1353739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1353767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1255744,1257666,1255767,1257730],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":113,"address":[1255791,1256093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1256277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1256502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[1256727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[1256952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1257177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1257399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1260336,1262873,1257760,1260297],"length":1,"stats":{"Line":1},"fn_name":"evaluate_log\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e"},{"line":124,"address":[1262912,1260374,1257986,1263264,1257798,1263230,1260562,1263582],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e"},{"line":125,"address":[1263101,1263512,1263453,1263160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1263664,1263616,1263684,1263636],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e"},{"line":129,"address":[1257861,1260437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1263742,1264300,1264048,1263712,1264078,1263964],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}\u003cstd::io::cursor::Cursor\u003c\u0026str\u003e\u003e"},{"line":133,"address":[1260572,1258065,1264384,1264567,1264887,1260641,1257921,1260497,1257996,1264704],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e"},{"line":135,"address":[1260614,1258038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1260626,1258050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1260144,1262720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1262656,1260080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":37,"coverable":45},{"path":["/","__w","dqg","dqg","src","gap","mod.rs"],"content":"use std::{\n    process::{Command, Stdio},\n    time::Instant,\n};\n\nuse crate::{\n    debug::print_orbits_nauty_style, graph::Graph, permutation::Permutation,\n    quotient::generate_orbits, statistics::Statistics, Error,\n};\n\nmod print;\nuse print::write_gap_input;\n\nmod parser;\nuse parser::parse_representatives;\n\nmod search;\nuse search::{check_class, check_class_stats};\n\npub static GAP_IN_FILE: \u0026str = \"./dqg.g\";\n\n#[cfg(not(tarpaulin_include))]\npub fn gap_mode(\n    graph: \u0026Graph,\n    mut generators: Vec\u003cPermutation\u003e,\n    statistics: \u0026mut Option\u003cStatistics\u003e,\n) -\u003e Result\u003c(), Error\u003e {\n    if let Some(stats) = statistics {\n        return gap_mode_statistics(graph, generators, stats);\n    }\n\n    // Early exit if full quotient is descriptive.\n    let full_orbits = generate_orbits(\u0026mut generators);\n    if check_class(graph, full_orbits.clone())? {\n        print_orbits_nauty_style(full_orbits, None);\n        return Ok(());\n    }\n\n    write_gap_input(generators)?;\n\n    let gap = Command::new(\"gap\")\n        .arg(\"-b\")\n        .arg(\"-o\")\n        .arg(\"16G\")\n        .arg(\"--nointeract\")\n        .arg(GAP_IN_FILE)\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    let gap_out = gap.wait_with_output()?;\n\n    if gap_out.status.success() {\n        let representatives = parse_representatives(\u0026gap_out.stdout, graph.size())?;\n        for mut representative in representatives {\n            let orbits = generate_orbits(\u0026mut representative);\n            if check_class(graph, orbits.clone())? {\n                print_orbits_nauty_style(orbits, None);\n                break;\n            }\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\nfn gap_mode_statistics(\n    graph: \u0026Graph,\n    generators: Vec\u003cPermutation\u003e,\n    statistics: \u0026mut Statistics,\n) -\u003e Result\u003c(), Error\u003e {\n    if !generators.is_empty() {\n        write_gap_input(generators)?;\n        let before_gap_time = Instant::now();\n\n        let gap = Command::new(\"gap\")\n            .arg(\"-b\")\n            .arg(\"-o\")\n            .arg(\"4G\")\n            .arg(\"--nointeract\")\n            .arg(GAP_IN_FILE)\n            .stdout(Stdio::piped())\n            .spawn()?;\n\n        let gap_out = gap.wait_with_output()?;\n        statistics.log_gap_done(before_gap_time.elapsed());\n\n        if gap_out.status.success() {\n            let representatives = parse_representatives(\u0026gap_out.stdout, graph.size())?;\n            for mut representative in representatives {\n                if check_class_stats(graph, \u0026mut representative, statistics)? {\n                    //print_orbits_nauty_style(orbits, Some(statistics));\n                    break;\n                }\n            }\n        }\n    }\n\n    statistics.exhausted = true;\n    statistics.log_end();\n    statistics.save_statistics()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","gap","parser.rs"],"content":"use crate::{\n    graph::VertexIndex,\n    parser::{BinInput, BinParseResult},\n    permutation::Permutation,\n    Error,\n};\n\nuse nom::{\n    character::complete::{char, i32, line_ending, multispace0},\n    combinator::map,\n    multi::{many1, separated_list1},\n    sequence::{delimited, preceded, tuple},\n};\n\nfn parse_cycle(input: BinInput\u003c'_\u003e) -\u003e BinParseResult\u003c'_, Vec\u003cVertexIndex\u003e\u003e {\n    let cycle = separated_list1(char(','), preceded(multispace0, map(i32, |i| i - 1)));\n    preceded(multispace0, delimited(char('('), cycle, char(')')))(input)\n}\n\nfn parse_permutation(input: BinInput\u003c'_\u003e, size: usize) -\u003e BinParseResult\u003c'_, Permutation\u003e {\n    map(many1(parse_cycle), |cycles| {\n        Permutation::from_cycles(cycles, size)\n    })(input)\n}\n\nfn parse_generators(input: BinInput\u003c'_\u003e, size: usize) -\u003e BinParseResult\u003c'_, Vec\u003cPermutation\u003e\u003e {\n    let generators = separated_list1(tuple((char(','), multispace0)), |input| {\n        parse_permutation(input, size)\n    });\n    delimited(\n        tuple((char('['), multispace0)),\n        generators,\n        tuple((multispace0, char(']'))),\n    )(input)\n}\n\npub fn parse_representatives(\n    input: BinInput\u003c'_\u003e,\n    size: usize,\n) -\u003e Result\u003cVec\u003cVec\u003cPermutation\u003e\u003e, Error\u003e {\n    separated_list1(line_ending, |input| parse_generators(input, size))(input)\n        .map(|(_, representatives)| representatives)\n        .map_err(Error::from)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_cycle() -\u003e Result\u003c(), Error\u003e {\n        let cycle = \"(1, 11,        13)\".as_bytes();\n\n        let expected = vec![0, 10, 12];\n        let (_, parsed) = parse_cycle(cycle)?;\n        assert_eq!(expected, parsed);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_permutation() -\u003e Result\u003c(), Error\u003e {\n        let permutation = \"(1,2,3,     4) \n(   23,    34,5)\"\n            .as_bytes();\n        let cycles = vec![vec![0, 1, 2, 3], vec![22, 33, 4]];\n        let size = 48;\n\n        let expected = Permutation::from_cycles(cycles, size);\n        let (_, parsed) = parse_permutation(permutation, size)?;\n        assert_eq!(expected, parsed);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_permutations() -\u003e Result\u003c(), Error\u003e {\n        let permutations = \"[ (   66,   46, 54,2)(12,23),\n(67,21,567, 65)\n ]\"\n        .as_bytes();\n        let size = 1000;\n        let cycles1 = vec![vec![65, 45, 53, 1], vec![11, 22]];\n        let permutation1 = Permutation::from_cycles(cycles1, size);\n        let cycles2 = vec![vec![66, 20, 566, 64]];\n        let permutation2 = Permutation::from_cycles(cycles2, size);\n\n        let expected = vec![permutation1, permutation2];\n        let (_, parsed) = parse_generators(permutations, size)?;\n        assert_eq!(expected, parsed);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_representatives() -\u003e Result\u003c(), Error\u003e {\n        let reps = \"[ (  1, 17)(  2, 18)(  3, 19)(  4, 20)(  5, 21), \n        (  9, 17, 25)( 10, 18, 26)( 11, 19, 27)( 12, 20, 28)]\n[ (  1, 17)(  2, 18)(  3, 19) ]\n\"\n        .as_bytes();\n        let size = 30;\n        let cycles1 = vec![\n            vec![0, 16],\n            vec![1, 17],\n            vec![2, 18],\n            vec![3, 19],\n            vec![4, 20],\n        ];\n        let permutation1 = Permutation::from_cycles(cycles1, size);\n        let cycles2 = vec![\n            vec![8, 16, 24],\n            vec![9, 17, 25],\n            vec![10, 18, 26],\n            vec![11, 19, 27],\n        ];\n        let permutation2 = Permutation::from_cycles(cycles2, size);\n        let repr1 = vec![permutation1, permutation2];\n        let cycles3 = vec![vec![0, 16], vec![1, 17], vec![2, 18]];\n        let permutation3 = Permutation::from_cycles(cycles3, size);\n        let repr2 = vec![permutation3];\n\n        let expected = vec![repr1, repr2];\n        let parsed = parse_representatives(reps, size)?;\n        assert_eq!(expected, parsed);\n\n        Ok(())\n    }\n}\n","traces":[{"line":15,"address":[1415984],"length":1,"stats":{"Line":1},"fn_name":"parse_cycle"},{"line":16,"address":[1416018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[1416059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1416176],"length":1,"stats":{"Line":1},"fn_name":"parse_permutation"},{"line":23,"address":[1528092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1416304],"length":1,"stats":{"Line":1},"fn_name":"parse_generators"},{"line":27,"address":[1416352],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[1528165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1416576],"length":1,"stats":{"Line":1},"fn_name":"parse_representatives"},{"line":41,"address":[1416623],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[1528272,1528275],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"}],"covered":11,"coverable":11},{"path":["/","__w","dqg","dqg","src","gap","print.rs"],"content":"use itertools::Itertools;\nuse std::{\n    fs::File,\n    io::{BufWriter, Write},\n};\n\nuse super::GAP_IN_FILE;\nuse crate::{permutation::Permutation, Error};\n\n#[cfg(not(tarpaulin_include))]\nfn write_permutation_gap(\n    writer: \u0026mut impl Write,\n    permutation: \u0026mut Permutation,\n) -\u003e Result\u003c(), Error\u003e {\n    let cycles = permutation.get_cycles();\n    if cycles.is_empty() {\n        return write!(writer, \"()\").map_err(Error::from);\n    }\n\n    for cycle in cycles {\n        write!(writer, \"(\")?;\n        Itertools::intersperse(cycle.into_iter().map(|vertex| Some(vertex + 1)), None)\n            .map(|element| {\n                if let Some(i) = element {\n                    write!(writer, \"{}\", i)\n                } else {\n                    write!(writer, \",\")\n                }\n            })\n            .try_collect()?;\n        write!(writer, \")\")?;\n    }\n\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn write_gap_input(permutations: Vec\u003cPermutation\u003e) -\u003e Result\u003c(), Error\u003e {\n    let mut gap_in_file = BufWriter::new(File::create(GAP_IN_FILE)?);\n\n    write!(gap_in_file, \"g:=Group([\")?;\n    for mut permutation in permutations {\n        write_permutation_gap(\u0026mut gap_in_file, \u0026mut permutation)?;\n        writeln!(gap_in_file, \",\")?;\n    }\n    writeln!(gap_in_file, \"]);;\")?;\n    writeln!(\n        gap_in_file,\n        r#\"\nc:=ConjugacyClassesSubgroups(g);;\nc_length:=Length(c);;\nfor i in [2..c_length] do\n    Print(GeneratorsOfGroup(Representative(c[i])));\n    Print(\"\\n\");\nod;;\"#\n    )\n    .map_err(Error::from)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","gap","search.rs"],"content":"use std::time::Instant;\n\nuse crate::{\n    encoding::encode_problem,\n    graph::Graph,\n    graph::VertexIndex,\n    permutation::Permutation,\n    quotient::{generate_orbits, QuotientGraph},\n    sat_solving::solve,\n    statistics::{QuotientStatistics, Statistics},\n    time, Error,\n};\n\n#[cfg(not(tarpaulin_include))]\npub fn check_class(graph: \u0026Graph, representative_orbits: Vec\u003cVertexIndex\u003e) -\u003e Result\u003cbool, Error\u003e {\n    let quotient = QuotientGraph::from_graph_orbits(graph, representative_orbits);\n    if let Some((formula, _)) = encode_problem(\u0026quotient, graph) {\n        solve(formula)\n    } else {\n        Ok(true)\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn check_class_stats(\n    graph: \u0026Graph,\n    representative_group: \u0026mut [Permutation],\n    statistics: \u0026mut Statistics,\n) -\u003e Result\u003cbool, Error\u003e {\n    let start_time = Instant::now();\n\n    time!(\n        orbit_gen_time,\n        orbits,\n        generate_orbits(representative_group)\n    );\n\n    time!(\n        quotient_gen_time,\n        quotient,\n        QuotientGraph::from_graph_orbits(graph, orbits)\n    );\n    let quotient_size = quotient.quotient_graph.size();\n\n    let min_max_orbit_size = quotient.get_orbit_sizes();\n    let (min_orbit_size, max_orbit_size) = min_max_orbit_size;\n\n    time!(encoding_time, formula, encode_problem(\u0026quotient, graph));\n\n    time!(\n        kissat_time,\n        descriptive,\n        if let Some((formula, _)) = formula {\n            solve(formula)\n        } else {\n            Ok(true)\n        }\n    );\n\n    let result = matches!(descriptive, Ok(true));\n\n    let quotient_stats = QuotientStatistics {\n        quotient_size,\n        core_size: None,\n        max_orbit_size,\n        min_orbit_size,\n        descriptive,\n        validated: None,\n        quotient_handling_time: start_time.elapsed(),\n        kissat_time,\n        orbit_gen_time,\n        quotient_gen_time,\n        encoding_time,\n        orbit_sizes: Default::default(),\n    };\n    statistics.log_quotient_statistic(quotient_stats);\n    statistics.log_iteration();\n\n    Ok(result)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","graph","internal_graph.rs"],"content":"use custom_debug_derive::Debug;\n\nuse super::{Colour, GraphError, VertexIndex, DEFAULT_COLOR};\n\n#[derive(std::fmt::Debug, PartialEq, Eq, Clone)]\npub enum GraphState {\n    IndexOrdered,\n    ColourGrouped,\n    ColourGroupedOrdered,\n    Chaos,\n    Fixed,\n    SparseSorted,\n}\n\n/// Fixed size graph.\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct Graph {\n    pub vertices: Vec\u003cVertex\u003e,\n    size: usize,\n    edge_number: usize,\n    #[debug(skip)]\n    pub state: GraphState,\n    max_color: Colour,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Vertex {\n    pub index: VertexIndex,\n    pub edges_to: Vec\u003cVertexIndex\u003e,\n    pub colour: Colour,\n}\n\nimpl Graph {\n    pub fn size(\u0026self) -\u003e usize {\n        self.size\n    }\n\n    pub fn number_edges(\u0026self) -\u003e usize {\n        self.edge_number\n    }\n\n    pub fn is_sparse(\u0026self) -\u003e bool {\n        // A complete graph has n(n-1)/2 edges for n vertices.\n        // We draw the line between sparse and dense at half\n        // of the possible edges in a complete graph.\n        self.edge_number \u003c self.size * (self.size - 1) / 4\n    }\n\n    #[inline]\n    pub fn update_max_color(\u0026mut self, color: Colour) {\n        if color \u003e self.max_color {\n            self.max_color = color;\n        }\n    }\n\n    pub fn new_ordered(n: usize) -\u003e Self {\n        let mut vertices = Vec::with_capacity(n);\n        for index in 0..n {\n            vertices.push(Vertex::new(index as VertexIndex, DEFAULT_COLOR));\n        }\n        Graph {\n            vertices,\n            size: n,\n            edge_number: 0,\n            state: GraphState::IndexOrdered,\n            max_color: -1,\n        }\n    }\n\n    pub fn new_with_indices(indices: \u0026[VertexIndex], is_sorted: bool) -\u003e Self {\n        let mut vertices = Vec::with_capacity(indices.len());\n        for index in indices {\n            vertices.push(Vertex::new(*index, DEFAULT_COLOR));\n        }\n        Graph {\n            vertices,\n            size: indices.len(),\n            edge_number: 0,\n            state: if is_sorted {\n                GraphState::SparseSorted\n            } else {\n                GraphState::Chaos\n            },\n            max_color: -1,\n        }\n    }\n\n    pub fn set_vertex(\u0026mut self, new_vertex: Vertex) -\u003e Result\u003c(), GraphError\u003e {\n        use GraphState::*;\n        self.update_max_color(new_vertex.colour);\n        let index = new_vertex.index;\n        if self.state == IndexOrdered {\n            *self\n                .vertices\n                .get_mut(index as usize)\n                .ok_or(GraphError(index))? = new_vertex;\n        } else {\n            *self\n                .vertices\n                .iter_mut()\n                .find(|vertex| vertex.index == index)\n                .ok_or(GraphError(index))? = new_vertex;\n            if self.state != Fixed {\n                self.state = Chaos;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn get_vertex(\u0026self, index: VertexIndex) -\u003e Result\u003c\u0026Vertex, GraphError\u003e {\n        match self.state {\n            GraphState::IndexOrdered =\u003e self.vertices.get(index as usize).ok_or(GraphError(index)),\n            GraphState::SparseSorted =\u003e Ok(\u0026self.vertices[self\n                .vertices\n                .binary_search_by(|vertex| vertex.index.cmp(\u0026index))\n                .unwrap()]),\n            _ =\u003e self\n                .vertices\n                .iter()\n                .find(|vertex| vertex.index == index)\n                .ok_or(GraphError(index)),\n        }\n    }\n\n    fn get_vertex_mut(\u0026mut self, index: VertexIndex) -\u003e Result\u003c\u0026mut Vertex, GraphError\u003e {\n        match self.state {\n            GraphState::IndexOrdered =\u003e self\n                .vertices\n                .get_mut(index as usize)\n                .ok_or(GraphError(index)),\n            GraphState::SparseSorted =\u003e {\n                let found_index = self\n                    .vertices\n                    .binary_search_by(|vertex| vertex.index.cmp(\u0026index))\n                    .unwrap();\n                Ok(\u0026mut self.vertices[found_index])\n            }\n            _ =\u003e self\n                .vertices\n                .iter_mut()\n                .find(|vertex| vertex.index == index)\n                .ok_or(GraphError(index)),\n        }\n    }\n\n    pub fn add_arc(\u0026mut self, start: VertexIndex, end: VertexIndex) -\u003e Result\u003c(), GraphError\u003e {\n        self.get_vertex_mut(start)?.add_edge(end);\n        self.edge_number += 1;\n        Ok(())\n    }\n\n    pub fn add_edge(\u0026mut self, start: VertexIndex, end: VertexIndex) -\u003e Result\u003c(), GraphError\u003e {\n        self.add_arc(start, end)?;\n        self.add_arc(end, start)?;\n        Ok(())\n    }\n\n    pub fn lookup_edge(\u0026self, start: \u0026VertexIndex, end: \u0026VertexIndex) -\u003e bool {\n        let start = *start as usize;\n        debug_assert!(start \u003c self.size);\n        self.vertices[start].edges_to.binary_search(end).is_ok()\n    }\n\n    pub fn iterate_edges(\u0026self) -\u003e impl Iterator\u003cItem = (VertexIndex, VertexIndex)\u003e + '_ {\n        self.vertices\n            .iter()\n            .flat_map(|vertex| vertex.edges_to.iter().map(move |end| (vertex.index, *end)))\n    }\n\n    /// Remove unneccessary edges.\n    /// Does so by first sorting, thus trading runtime for reduced memory footprint.\n    pub fn minimize(\u0026mut self) {\n        // Adjust the edge number to fit, too.\n        self.edge_number = 0;\n        for vertex in self.vertices.iter_mut() {\n            vertex.edges_to.sort_unstable();\n            vertex.edges_to.dedup();\n            self.edge_number += vertex.edges_to.len();\n        }\n    }\n\n    pub fn set_colours(\u0026mut self, colours: \u0026[Colour]) -\u003e Result\u003c(), GraphError\u003e {\n        for (index, colour) in colours.iter().enumerate() {\n            self.get_vertex_mut(index as VertexIndex)?.colour = *colour;\n        }\n\n        Ok(())\n    }\n\n    #[cfg(test)]\n    pub fn order(\u0026mut self, order: \u0026[VertexIndex]) -\u003e Result\u003c(), GraphError\u003e {\n        let mut ordered_vertices = Vec::with_capacity(self.vertices.len());\n        for index in order {\n            let vertex = self.get_vertex(*index)?;\n            ordered_vertices.push(vertex.clone());\n        }\n\n        self.vertices = ordered_vertices;\n        self.state = GraphState::Fixed;\n        Ok(())\n    }\n\n    pub fn group_colours(\u0026mut self) {\n        use GraphState::*;\n        match self.state {\n            IndexOrdered =\u003e {\n                self.vertices.sort_by(|a, b| a.colour.cmp(\u0026b.colour));\n                self.state = ColourGroupedOrdered;\n            }\n            Chaos =\u003e {\n                self.vertices\n                    .sort_unstable_by(|a, b| a.colour.cmp(\u0026b.colour));\n                self.state = ColourGrouped;\n            }\n            _ =\u003e (),\n        }\n    }\n\n    pub fn sort(\u0026mut self) {\n        if self.state == GraphState::SparseSorted {\n            return;\n        }\n\n        if self.state != GraphState::IndexOrdered {\n            self.vertices.sort_unstable();\n            for vertex in self.vertices.iter_mut() {\n                vertex.edges_to.sort_unstable();\n            }\n            self.state = GraphState::IndexOrdered;\n        }\n    }\n\n    pub fn induce_subgraph(\n        \u0026self,\n        remaining_vertices: \u0026[VertexIndex],\n        vertex_list_sorted: bool,\n    ) -\u003e Result\u003cSelf, GraphError\u003e {\n        let mut subgraph = Self::new_with_indices(remaining_vertices, vertex_list_sorted);\n\n        for vertex in self.vertices.iter() {\n            let include = {\n                if vertex_list_sorted {\n                    remaining_vertices.binary_search(\u0026vertex.index).is_ok()\n                } else {\n                    remaining_vertices.contains(\u0026vertex.index)\n                }\n            };\n\n            if include {\n                let new_vertex = subgraph.get_vertex_mut(vertex.index)?;\n                new_vertex.colour = vertex.colour;\n                let sub_edges = vertex\n                    .edges_to\n                    .iter()\n                    .cloned()\n                    .filter(|vertex| {\n                        if vertex_list_sorted {\n                            remaining_vertices.binary_search(vertex).is_ok()\n                        } else {\n                            remaining_vertices.contains(vertex)\n                        }\n                    })\n                    .collect();\n                new_vertex.edges_to = sub_edges;\n            }\n        }\n\n        let sub_edge_number = subgraph.iterate_edges().count();\n        subgraph.edge_number = sub_edge_number;\n\n        Ok(subgraph)\n    }\n\n    pub fn recolor(\u0026mut self, vertex: VertexIndex) -\u003e Result\u003c(), GraphError\u003e {\n        let next_color = self.max_color;\n        self.max_color = next_color + 1;\n        let vertex = self.get_vertex_mut(vertex)?;\n        vertex.colour = next_color;\n        Ok(())\n    }\n}\n\nimpl Vertex {\n    pub fn new(index: VertexIndex, colour: Colour) -\u003e Self {\n        Vertex {\n            index,\n            edges_to: Vec::new(),\n            colour,\n        }\n    }\n\n    pub fn add_edge(\u0026mut self, end: VertexIndex) {\n        self.edges_to.push(end);\n    }\n}\n\nimpl PartialOrd for Vertex {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        Some(self.index.cmp(\u0026other.index))\n    }\n}\n\nimpl Ord for Vertex {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.index.cmp(\u0026other.index)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn new_graph_default() {\n        let graph = Graph::new_ordered(120);\n        assert!(graph.is_sparse());\n        for (index, vertex) in graph.vertices.iter().enumerate() {\n            assert_eq!(index as VertexIndex, vertex.index);\n            assert_eq!(DEFAULT_COLOR, vertex.colour);\n            assert!(vertex.edges_to.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_set_vertex() {\n        let mut graph = Graph::new_ordered(5);\n        assert_eq!(5, graph.size());\n        assert_eq!(GraphState::IndexOrdered, graph.state);\n\n        // First with IndexOrdered\n\n        // In bounds\n        let valid_vertex = Vertex::new(2, 45);\n        assert_eq!(Ok(()), graph.set_vertex(valid_vertex.clone()));\n\n        // Negative index\n        let negative_vertex = Vertex::new(-23, 9);\n        assert_eq!(Err(GraphError(-23)), graph.set_vertex(negative_vertex));\n\n        // Index out of bounds\n        let oob_vertex = Vertex::new(5, 124);\n        assert_eq!(Err(GraphError(5)), graph.set_vertex(oob_vertex));\n\n        // Then with another state\n        graph.state = GraphState::Chaos;\n\n        // In bounds\n        let valid_vertex_chaos = Vertex::new(3, 50);\n        assert_eq!(Ok(()), graph.set_vertex(valid_vertex_chaos.clone()));\n\n        // Negative index\n        let negative_vertex_chaos = Vertex::new(-120, 9);\n        assert_eq!(\n            Err(GraphError(-120)),\n            graph.set_vertex(negative_vertex_chaos)\n        );\n\n        // Index out of bounds\n        let oob_vertex_chaos = Vertex::new(5, 124);\n        assert_eq!(Err(GraphError(5)), graph.set_vertex(oob_vertex_chaos));\n\n        assert_eq!(graph.vertices[0], Vertex::new(0, DEFAULT_COLOR));\n        assert_eq!(graph.vertices[1], Vertex::new(1, DEFAULT_COLOR));\n        assert_eq!(graph.vertices[2], valid_vertex);\n        assert_eq!(graph.vertices[3], valid_vertex_chaos);\n        assert_eq!(graph.vertices[4], Vertex::new(4, DEFAULT_COLOR));\n    }\n\n    #[test]\n    fn test_get_vertex() -\u003e Result\u003c(), GraphError\u003e {\n        let mut graph = Graph::new_ordered(5);\n        assert_eq!(5, graph.size());\n        assert_eq!(GraphState::IndexOrdered, graph.state);\n\n        // First with IndexOrdered\n\n        // In bounds\n        let valid_result = graph.get_vertex_mut(2)?;\n        assert_eq!(\u0026mut Vertex::new(2, DEFAULT_COLOR), valid_result);\n\n        // Negative index\n        assert_eq!(Err(GraphError(-3)), graph.get_vertex_mut(-3));\n\n        // Index out of bounds\n        assert_eq!(Err(GraphError(5)), graph.get_vertex_mut(5));\n\n        // Then with another state\n        graph.state = GraphState::Chaos;\n\n        // In bounds\n        let valid_result = graph.get_vertex_mut(3)?;\n        assert_eq!(\u0026mut Vertex::new(3, DEFAULT_COLOR), valid_result);\n\n        // Negative index\n        assert_eq!(Err(GraphError(-1)), graph.get_vertex_mut(-1));\n\n        // Index out of bounds\n        assert_eq!(Err(GraphError(5)), graph.get_vertex_mut(5));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_induce_subgraph() -\u003e Result\u003c(), GraphError\u003e {\n        let mut graph = Graph::new_ordered(5);\n        for i in 0..4 {\n            graph.add_edge(i, i + 1)?;\n        }\n\n        let vertex_subset = vec![1, 3, 4];\n\n        let mut expected_subgraph = Graph::new_with_indices(\u0026vertex_subset, true);\n        expected_subgraph.add_edge(3, 4)?;\n\n        assert_eq!(\n            expected_subgraph,\n            graph.induce_subgraph(\u0026vertex_subset, true)?\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":34,"address":[1295488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1295493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1295504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1295509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1295520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1295657,1295529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1295696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1295732,1295714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1295729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1296149,1295744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[1295779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[1295881,1295789,1296086],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[1296102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1296176,1296662,1296637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1296242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1296278,1296470,1296346],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[1296483,1296625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1296464,1296510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1296672,1297540,1297990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1296697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1296790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1296800,1297918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1297639,1297930,1297608,1297739,1296947],"length":1,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[1297600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1297980,1297725,1296908,1297625,1297549,1297910,1297952],"length":1,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[1297224,1297124,1297463,1296881,1297018,1297077],"length":1,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[1297069],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[1296842,1297485,1296967,1297530,1297210,1297377,1297110],"length":1,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[1297385,1297453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[1297435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1297417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1298016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1298046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1298168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1298223,1298244,1298367],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[1298234],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[1298150,1298119,1298083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1298109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1298142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1298416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[1298447],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[1298608,1298587,1298571],"length":1,"stats":{"Line":9},"fn_name":null},{"line":129,"address":[1298582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[1298600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[1298648,1298781,1298627],"length":1,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[1298638],"length":1,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[1298786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1298485,1298552,1298521],"length":1,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[1298511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[1298544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1298832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1298865,1298946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[1299000,1298924,1298986],"length":1,"stats":{"Line":6},"fn_name":null},{"line":149,"address":[1298990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[1299056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1299085,1299163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1299129,1299072,1299203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[1299193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1299248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1299276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[1299298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[1299341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1299424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1299456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1584186,1584080,1584117,1584176],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":172,"address":[1299504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[1299518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[1299696,1299526,1299609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[1299624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[1299645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1299655,1299701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1299744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1299930,1300052,1299806],"length":1,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[1299956,1300033,1300057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1299915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1300096,1300740,1300715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1300142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1300254,1300372,1300186],"length":1,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[1300385,1300575,1300684,1300620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[1300665,1300613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1300410,1300326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1300512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1300530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1300752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1300766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1300838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1300805],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[1300826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1300878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1300845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[1584288,1584331],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":213,"address":[1300866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[1300880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1300893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1301060,1300917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[1300946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1300966,1301062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1301072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1301048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1301104,1302239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1301171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1301468,1301295,1301216],"length":1,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[1301489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[1301655,1301730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1301696,1301619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[1302216,1301705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[1301789,1301912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1301877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1301953,1302039,1301883],"length":1,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[1302015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[1584375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1584425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[1584392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1302098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[1301461,1301513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[1301538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1301546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1302272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1302294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1302305,1302371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[1302334,1302403,1302426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1302413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1302416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1302480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[1302509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[1302576],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[1302589],"length":1,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[1302608],"length":1,"stats":{"Line":1},"fn_name":"partial_cmp"},{"line":299,"address":[1302622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1302656],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":305,"address":[1302670],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":110,"coverable":131},{"path":["/","__w","dqg","dqg","src","graph","mod.rs"],"content":"//! Representation of graphs as well as\n//! functionalities to build them from\n//! simple building blocks or switch to\n//! to a representation understand by nauty.\nuse custom_debug_derive::Debug;\nuse std::os::raw::c_int;\n\nmod internal_graph;\npub use internal_graph::{Graph, GraphState, Vertex};\n\nmod nauty_traces_graph;\npub use nauty_traces_graph::{NautyGraph, SparseNautyGraph, TracesGraph};\n\npub type Colour = c_int;\npub type VertexIndex = c_int;\n\npub const DEFAULT_COLOR: Colour = c_int::MAX;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct GraphError(VertexIndex);\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","graph","nauty_traces_graph.rs"],"content":"use custom_debug_derive::Debug;\nuse itertools::Itertools;\nuse nauty_Traces_sys::{empty_graph, SparseGraph, ADDONEEDGE, SETWORDSNEEDED};\nuse std::{convert::TryInto, os::raw::c_int};\n\nuse super::{Colour, Graph, GraphState, VertexIndex};\nuse crate::debug::bin_fmt;\n\nfn encode_colours(partition: \u0026mut [Colour]) {\n    let mut last_colour = c_int::MIN; // Negative numbers should not arise or if they do, they should be bigger than this.\n    for colour in partition.iter_mut().rev() {\n        if *colour != last_colour {\n            last_colour = *colour;\n            *colour = 0;\n        } else {\n            *colour = 1;\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct NautyGraph {\n    /// actual graph\n    #[debug(with = \"bin_fmt\")]\n    pub adjacency_matrix: Vec\u003cu64\u003e,\n    /// lab\n    pub vertex_order: Vec\u003cVertexIndex\u003e,\n    /// ptn aka the colouring\n    pub partition: Vec\u003cVertexIndex\u003e,\n}\n\n#[derive(Debug)]\npub struct TracesGraph {\n    /// actual graph\n    pub sparse_graph: SparseGraph,\n    /// lab\n    pub vertex_order: Vec\u003cVertexIndex\u003e,\n    /// ptn aka the colouring\n    pub partition: Vec\u003cVertexIndex\u003e,\n}\n\npub type SparseNautyGraph = TracesGraph;\n\nimpl NautyGraph {\n    pub fn from_graph(graph: \u0026mut Graph) -\u003e NautyGraph {\n        let n = graph.size();\n        let m = SETWORDSNEEDED(n);\n\n        let mut nauty_graph = NautyGraph {\n            adjacency_matrix: empty_graph(m, n),\n            vertex_order: Vec::with_capacity(n),\n            partition: Vec::with_capacity(n),\n        };\n\n        if graph.state != GraphState::Fixed {\n            graph.sort();\n            graph.group_colours();\n        }\n\n        for vertex in graph.vertices.iter() {\n            nauty_graph.vertex_order.push(vertex.index);\n\n            nauty_graph.partition.push(vertex.colour);\n\n            for end in vertex.edges_to.iter() {\n                ADDONEEDGE(\n                    \u0026mut nauty_graph.adjacency_matrix,\n                    vertex.index as usize,\n                    *end as usize,\n                    m,\n                );\n            }\n        }\n\n        encode_colours(\u0026mut nauty_graph.partition);\n\n        nauty_graph\n    }\n\n    pub fn check_valid(\u0026self) -\u003e bool {\n        let n = self.partition.len();\n        let m = SETWORDSNEEDED(n);\n\n        self.adjacency_matrix.len() == n * m \u0026\u0026 self.vertex_order.len() == n\n    }\n\n    pub fn graph_repr_sizes(\u0026self) -\u003e (usize, usize) {\n        let n = self.partition.len();\n        (n, SETWORDSNEEDED(n))\n    }\n}\n\nimpl TracesGraph {\n    pub fn from_graph(graph: \u0026mut Graph) -\u003e TracesGraph {\n        let number_vertices = graph.size();\n        let number_edges = graph.number_edges();\n\n        let mut traces_graph = TracesGraph {\n            sparse_graph: SparseGraph::new(number_vertices, number_edges),\n            vertex_order: Vec::with_capacity(number_vertices),\n            partition: Vec::with_capacity(number_vertices),\n        };\n\n        if graph.state != GraphState::Fixed {\n            graph.sort();\n            graph.group_colours();\n        }\n\n        // Encode order and colors\n        for vertex in graph.vertices.iter() {\n            traces_graph.vertex_order.push(vertex.index);\n            traces_graph.partition.push(vertex.colour);\n        }\n        encode_colours(\u0026mut traces_graph.partition);\n\n        // Encode graph. Vertices must be ordered with increasing indices.\n        let mut edge_counter = 0usize;\n        for (index, vertex) in graph.vertices.iter().sorted().enumerate() {\n            debug_assert_eq!(index as i32, vertex.index);\n            traces_graph.sparse_graph.d[index] = vertex.edges_to.len().try_into().unwrap();\n            traces_graph.sparse_graph.v[index] = edge_counter;\n\n            for end in vertex.edges_to.iter() {\n                traces_graph.sparse_graph.e[edge_counter] = *end;\n                edge_counter += 1;\n            }\n        }\n\n        traces_graph\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use nauty_Traces_sys::{\n        densenauty, optionblk, statsblk, Traces, TracesOptions, TracesStats, FALSE,\n    };\n\n    use crate::graph::GraphError;\n\n    use super::*;\n\n    #[test]\n    fn correct_nauty_repr() -\u003e Result\u003c(), GraphError\u003e {\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(1, 5)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 7)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(4, 7)?;\n        graph.add_edge(5, 6)?;\n        graph.add_edge(6, 7)?;\n\n        let order = [2, 0, 1, 3, 4, 5, 6, 7];\n        let colours = [2, 2, 1, 2, 2, 2, 2, 2];\n        graph.set_colours(\u0026colours)?;\n        graph.order(\u0026order)?;\n\n        let mut nauty_graph = NautyGraph::from_graph(\u0026mut graph);\n        assert_eq!(nauty_graph.vertex_order, order);\n        assert_eq!(nauty_graph.partition, [0, 1, 1, 1, 1, 1, 1, 0]);\n        assert!(nauty_graph.check_valid());\n        assert_eq!(nauty_graph.graph_repr_sizes(), (8, 1));\n\n        let mut options = optionblk::default();\n        options.writeautoms = FALSE;\n        options.defaultptn = FALSE;\n        let mut stats = statsblk::default();\n        let mut orbits = vec![0; 8];\n\n        unsafe {\n            densenauty(\n                nauty_graph.adjacency_matrix.as_mut_ptr(),\n                nauty_graph.vertex_order.as_mut_ptr(),\n                nauty_graph.partition.as_mut_ptr(),\n                orbits.as_mut_ptr(),\n                \u0026mut options,\n                \u0026mut stats,\n                1,\n                8,\n                std::ptr::null_mut(),\n            );\n        }\n\n        assert_eq!(orbits, [0, 1, 2, 1, 4, 0, 1, 0]);\n        Ok(())\n    }\n\n    #[test]\n    fn correct_nauty_repr2() -\u003e Result\u003c(), GraphError\u003e {\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(1, 5)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 7)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(4, 7)?;\n        graph.add_edge(5, 6)?;\n        graph.add_edge(6, 7)?;\n\n        let mut nauty_graph = NautyGraph::from_graph(\u0026mut graph);\n        assert_eq!(nauty_graph.vertex_order, [0, 1, 2, 3, 4, 5, 6, 7]);\n        assert_eq!(nauty_graph.partition, [1, 1, 1, 1, 1, 1, 1, 0]);\n        assert!(nauty_graph.check_valid());\n        assert_eq!(nauty_graph.graph_repr_sizes(), (8, 1));\n\n        let mut options = optionblk::default();\n        options.writeautoms = FALSE;\n        let mut stats = statsblk::default();\n        let mut orbits = vec![0; 8];\n\n        unsafe {\n            densenauty(\n                nauty_graph.adjacency_matrix.as_mut_ptr(),\n                nauty_graph.vertex_order.as_mut_ptr(),\n                nauty_graph.partition.as_mut_ptr(),\n                orbits.as_mut_ptr(),\n                \u0026mut options,\n                \u0026mut stats,\n                1,\n                8,\n                std::ptr::null_mut(),\n            );\n        }\n\n        assert_eq!(orbits, [0, 0, 0, 0, 0, 0, 0, 0]);\n        Ok(())\n    }\n\n    #[test]\n    fn correct_traces_repr() -\u003e Result\u003c(), GraphError\u003e {\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(1, 5)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 7)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(4, 7)?;\n        graph.add_edge(5, 6)?;\n        graph.add_edge(6, 7)?;\n\n        let order = [2, 1, 0, 3, 4, 5, 6, 7];\n        let colours = [2, 2, 1, 2, 2, 2, 2, 2];\n        graph.set_colours(\u0026colours)?;\n        graph.order(\u0026order)?;\n\n        let mut traces_graph = TracesGraph::from_graph(\u0026mut graph);\n        assert_eq!(traces_graph.vertex_order, order);\n        assert_eq!(traces_graph.partition, [0, 1, 1, 1, 1, 1, 1, 0]);\n\n        let mut options = TracesOptions::default();\n        options.defaultptn = FALSE;\n        options.digraph = FALSE;\n        options.getcanon = FALSE;\n        let mut stats = TracesStats::default();\n        let mut orbits = vec![0; 8];\n\n        unsafe {\n            Traces(\n                \u0026mut (\u0026mut traces_graph.sparse_graph).into(),\n                traces_graph.vertex_order.as_mut_ptr(),\n                traces_graph.partition.as_mut_ptr(),\n                orbits.as_mut_ptr(),\n                \u0026mut options,\n                \u0026mut stats,\n                std::ptr::null_mut(),\n            );\n        }\n\n        assert_eq!(orbits, [0, 1, 2, 1, 4, 0, 1, 0]);\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[828480],"length":1,"stats":{"Line":2},"fn_name":"encode_colours"},{"line":10,"address":[828494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[828502,828585],"length":1,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[828600,828619,828638],"length":1,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[828626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[828632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[828613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[828640,829750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[828690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[828725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[828764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[828797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[828864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[829088,829016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[829133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[829148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[829173,829348,829102],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[829369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[829451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[829474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[829670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[829727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[829731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[829323,829397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[829412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[829776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[829789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[829812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[829832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[829968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[829977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[830002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[830048,832143,832183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[830098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[830138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[830162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[830195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[830262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[830534,830462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[830579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[830594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[830619,830548,830812],"length":1,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[830836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[832160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[830781,830873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[830888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[830900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[831292,831352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[831716,831515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[831762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[831827,832105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[832018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[832070,832110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[831302],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":52,"coverable":54},{"path":["/","__w","dqg","dqg","src","input.rs"],"content":"//! Provides convenient functions to read\n//! graphs from stdin. Uses similar commands\n//! as dreadnaut.\n\nuse std::{\n    env::current_dir,\n    fs::File,\n    io::{self, BufReader, Stdin, Write},\n    path::PathBuf,\n};\nuse structopt::StructOpt;\n\nuse crate::{\n    graph::{Graph, VertexIndex},\n    misc::CoreMetric,\n    parser::{parse_csv_input, parse_dreadnaut_input, parse_txt_input},\n    statistics::{Statistics, StatisticsLevel},\n    Error, MetricUsed, NautyTraces, Settings,\n};\n\n#[derive(StructOpt, Debug)]\n#[structopt(name = \"DQG\")]\nstruct CommandLineOptions {\n    /// Test whole powerset of the generators.\n    #[structopt(short = \"-p\", long)]\n    iter_powerset: bool,\n    /// Read a file from command line.\n    #[structopt(short = \"-m\", long)]\n    read_memory_pipe: bool,\n    /// Outputs orbits in dreadnaut format.\n    #[structopt(short = \"-o\", long)]\n    output_orbits: bool,\n    /// Logs all orbit sizes in a HashMap.\n    #[structopt(short = \"-l\", long)]\n    log_orbits: bool,\n    /// Print formula instead of solving it.\n    #[structopt(short = \"-f\", long)]\n    print_formula: bool,\n    /// Graph is colored and colors should be\n    /// included in the nauty computation.\n    #[structopt(short = \"-c\", long)]\n    colored_graph: bool,\n    /// Use traces instead of nauty to compute\n    /// the graphs automorphism group.\n    #[structopt(short = \"-t\", long)]\n    use_traces: bool,\n    /// Use nondescriptive cores and the metric\n    /// to guide the search.\n    /// Possible values: recolor, pow_gen\n    #[structopt(short = \"-q\", long)]\n    nondescriptive_core: Option\u003cCoreMetric\u003e,\n    /// Search in the whole automorphism group instead\n    /// of a set of generators.\n    #[structopt(short = \"-g\", long)]\n    search_group: bool,\n    /// Validate each descriptiveness result\n    /// with exhaustive search for consistent\n    /// transversals.\n    #[structopt(short = \"-v\", long)]\n    validate: bool,\n    /// Operate in GAP mode.\n    /// This means that DQG use GAP to\n    /// search in the conjugacy classes.\n    #[structopt(long)]\n    gap_mode: bool,\n    /// GIve graph size for file formats\n    /// which don't contain the graph size.\n    #[structopt(short = \"-n\", long)]\n    graph_size: Option\u003cusize\u003e,\n    /// Use the given metric to find the \"best\" quotient\n    /// and use it as described by the other flags.\n    /// Possible value: least_orbits, biggest_orbit, sparsity\n    #[structopt(long)]\n    metric: Option\u003cMetricUsed\u003e,\n    /// Evaluate a log file as printed by\n    /// the quotientPlanning tool.\n    #[structopt(long, parse(from_os_str))]\n    evaluate: Option\u003cPathBuf\u003e,\n    /// Level of detail for statistics.\n    /// None if left out, basic if `-s`, full for more than one `-s`.\n    #[structopt(short = \"-s\", parse(from_occurrences = StatisticsLevel::from))]\n    statistics_level: StatisticsLevel,\n    /// The input file to read from. Optional.\n    /// Same path will be used for output.\n    /// Reads through CLI if not specified.\n    #[structopt(parse(from_os_str))]\n    input: Option\u003cPathBuf\u003e,\n}\n\n#[cfg(not(tarpaulin_include))]\nfn read_graph_empty(stdin: \u0026Stdin) -\u003e Result\u003cGraph, io::Error\u003e {\n    let mut buffer = String::new();\n    let number_of_vertices;\n\n    println!(\"Input graph size:\");\n    loop {\n        print!(\"n=\");\n        io::stdout().flush()?;\n        stdin.read_line(\u0026mut buffer)?;\n\n        match buffer.trim().parse::\u003cusize\u003e() {\n            Ok(n) =\u003e {\n                number_of_vertices = n;\n                break;\n            }\n            Err(_) =\u003e println!(\"Please insert only natural numbers in decimal!\"),\n        }\n\n        buffer.clear();\n    }\n\n    Ok(Graph::new_ordered(number_of_vertices))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn read_vertex(index: VertexIndex, graph: \u0026mut Graph, stdin: \u0026Stdin) -\u003e Result\u003cbool, Error\u003e {\n    let mut line_buffer = String::new();\n    let mut should_continue = true;\n\n    'input: loop {\n        print!(\"Edges from {}: \", index);\n        io::stdout().flush()?;\n\n        line_buffer.clear();\n        stdin.read_line(\u0026mut line_buffer)?;\n        for input_part in line_buffer.split_whitespace() {\n            if let Ok(end) = input_part.parse::\u003cVertexIndex\u003e() {\n                if end \u003c graph.size() as i32 {\n                    graph.add_edge(index, end)?;\n                } else {\n                    println!(\n                        \"Please only input valid vertex indices (i.e. between 0 and {})!\",\n                        graph.size()\n                    );\n                    continue 'input;\n                }\n            } else if input_part.chars().next().unwrap_or(' ') == ';' {\n                break 'input;\n            } else if input_part.chars().next().unwrap_or(' ') == '.' {\n                should_continue = false;\n                break 'input;\n            } else {\n                break;\n            }\n        }\n\n        println!(\"Please insert the edges from vertex {} in this format: `Edges from {}: #1 #2 #3 (;|.)` where \\\n#i is the vertex number of the end node of an edge from this vertex. Also end the line with a `;` to continue \\\nwith the next vertex or a `.` to end inputting edges.\", index, index);\n    }\n\n    Ok(should_continue)\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn read_graph() -\u003e Result\u003c(Graph, Settings), Error\u003e {\n    let cl_options = CommandLineOptions::from_args();\n\n    if let Some(eval_path) = cl_options.evaluate {\n        let eval_file = File::open(eval_path)?;\n        let buf = BufReader::new(eval_file);\n        return Ok((\n            Graph::new_ordered(0),\n            Settings {\n                evaluate: Some(buf),\n                ..Default::default()\n            },\n        ));\n    }\n\n    let mut use_traces = cl_options.use_traces;\n    let mut graph;\n    let mut out_file;\n\n    if let Some(path_to_graph_file) = cl_options.input {\n        // Either read the graph from a file ..\n        let file_buf = BufReader::new(File::open(\u0026path_to_graph_file)?);\n        let (parsed_graph, has_header) = match path_to_graph_file\n            .as_path()\n            .extension()\n            .unwrap()\n            .to_str()\n            .unwrap()\n        {\n            \"dre\" =\u003e parse_dreadnaut_input(file_buf)?,\n            \"csv\" =\u003e (\n                parse_csv_input(cl_options.graph_size.unwrap(), file_buf)?,\n                false,\n            ),\n            \"txt\" =\u003e (parse_txt_input(file_buf)?, false),\n            _ =\u003e unimplemented!(),\n        };\n        use_traces |= has_header;\n        graph = parsed_graph;\n\n        out_file = path_to_graph_file;\n        out_file.set_extension(\"dqg\");\n    } else {\n        // ... or from stdin.\n        let stdin = io::stdin();\n\n        if cl_options.read_memory_pipe {\n            // Stdin can either mean a memory pipe ...\n            let file_buf = BufReader::new(stdin.lock());\n            let (parsed_graph, has_header) = parse_dreadnaut_input(file_buf)?;\n            use_traces |= has_header;\n            graph = parsed_graph;\n        } else {\n            // .... or the interactive command line interface.\n            graph = read_graph_empty(\u0026stdin)?;\n\n            for i in 0..graph.size() {\n                if !read_vertex(i as VertexIndex, \u0026mut graph, \u0026stdin)? {\n                    break;\n                }\n            }\n        }\n\n        out_file =\n            current_dir().expect(\"Statistics feature requires current directory to be accessible!\");\n        out_file.push(\"statistics.dqg\");\n    }\n\n    // Start the statistics after the graph reading is done.\n    let statistics = if cl_options.statistics_level == StatisticsLevel::None {\n        None\n    } else {\n        Some(Statistics::new(\n            cl_options.statistics_level,\n            out_file,\n            graph.size(),\n        ))\n    };\n\n    let settings = Settings {\n        iter_powerset: cl_options.iter_powerset,\n        output_orbits: cl_options.output_orbits,\n        log_orbits: cl_options.log_orbits,\n        print_formula: cl_options.print_formula,\n        colored_graph: cl_options.colored_graph,\n        nondescriptive_core: cl_options.nondescriptive_core,\n        search_group: cl_options.search_group,\n        validate: cl_options.validate,\n        gap_mode: cl_options.gap_mode,\n        metric: cl_options.metric,\n        evaluate: None,\n        nauyt_or_traces: if use_traces {\n            NautyTraces::Traces\n        } else if graph.is_sparse() {\n            NautyTraces::SparseNauty\n        } else {\n            NautyTraces::Nauty\n        },\n        statistics,\n    };\n\n    Ok((graph, settings))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","main.rs"],"content":"#![warn(rust_2018_idioms)]\n//#![deny(warnings, missing_docs)]\n\n//! Project to find heuristics for\n//! descriptive quotients of graphs\n//! for certain conditions.\n\nuse itertools::Itertools;\nuse std::{\n    io::BufRead,\n    time::{Duration, Instant},\n};\n\nmod graph;\nuse graph::{Graph, NautyGraph};\n\nmod input;\nuse input::read_graph;\n\nmod quotient;\nuse quotient::{compute_generators, generate_orbits, search_group, QuotientGraph};\n\nmod encoding;\nuse encoding::{encode_problem, HighLevelEncoding};\n\nmod sat_solving;\nuse sat_solving::{solve, solve_validate};\n\nmod parser;\n\nmod statistics;\nuse statistics::{OrbitStatistics, QuotientStatistics, Statistics};\n\nmod debug;\npub use debug::Error;\n\nmod permutation;\nuse permutation::Permutation;\n\nmod metric;\n\nmod transversal;\nuse transversal::is_transversal_consistent;\n\nmod misc;\npub use misc::{do_if_some, MetricUsed, NautyTraces, Settings};\n\nmod evaluate;\nuse evaluate::{evaluate_log_file, evaluate_logs};\n\nmod gap;\nuse gap::gap_mode;\n\nmod core;\nuse crate::core::search_with_core;\n\n#[cfg(not(tarpaulin_include))]\nfn compute_quotient_with_statistics(\n    generators_subset: \u0026mut [Permutation],\n    graph: \u0026Graph,\n    settings: \u0026mut Settings,\n) -\u003e bool {\n    let start_time = Instant::now();\n\n    time!(orbit_gen_time, orbits, generate_orbits(generators_subset));\n\n    let mut orbit_sizes = OrbitStatistics::default();\n    if settings.log_orbits {\n        for orbit in orbits.encode_high() {\n            orbit_sizes.log_orbit(\u0026orbit);\n        }\n    }\n\n    time!(\n        quotient_gen_time,\n        quotient_graph,\n        QuotientGraph::from_graph_orbits(graph, orbits)\n    );\n    let quotient_size = quotient_graph.quotient_graph.size();\n    let (min_orbit_size, max_orbit_size) = quotient_graph.get_orbit_sizes();\n\n    time!(\n        encoding_time,\n        encoded,\n        encode_problem(\u0026quotient_graph, graph)\n    );\n\n    let mut descriptive = Ok(true);\n    let mut validated = None;\n    let mut kissat_time = Duration::ZERO;\n\n    let return_val = if let Some((formula, dict)) = encoded {\n        time!(k_time, descriptive_validated, {\n            if settings.validate {\n                let sat_result = solve_validate(formula, dict);\n                match sat_result {\n                    Ok(transversal) =\u003e {\n                        if let Some(transversal) = transversal {\n                            (\n                                Ok(true),\n                                Some(is_transversal_consistent(\n                                    \u0026transversal,\n                                    graph,\n                                    quotient_graph.encode_high(),\n                                )),\n                            )\n                        } else {\n                            (Ok(false), None)\n                        }\n                    }\n                    Err(err) =\u003e (Err(err), None),\n                }\n            } else {\n                let descriptive = solve(formula);\n                (descriptive, None)\n            }\n        });\n        kissat_time = k_time;\n        descriptive = descriptive_validated.0;\n        validated = descriptive_validated.1;\n\n        matches!(descriptive, Ok(true))\n    } else {\n        // Trivially descriptive\n        true\n    };\n\n    let quotient_handling_time = start_time.elapsed();\n    let quotient_stats = QuotientStatistics {\n        quotient_size,\n        core_size: None,\n        max_orbit_size,\n        min_orbit_size,\n        descriptive,\n        validated,\n        quotient_handling_time,\n        kissat_time,\n        orbit_gen_time,\n        quotient_gen_time,\n        encoding_time,\n        orbit_sizes,\n    };\n    do_if_some(settings.get_stats(), |stats| {\n        stats.log_quotient_statistic(quotient_stats);\n        stats.log_iteration()\n    });\n\n    return_val\n}\n\n#[cfg(not(tarpaulin_include))]\nfn compute_quotient(\n    generators_subset: \u0026mut [Permutation],\n    graph: \u0026Graph,\n    settings: \u0026Settings,\n) -\u003e bool {\n    let orbits = generate_orbits(generators_subset);\n\n    let quotient_graph = QuotientGraph::from_graph_orbits(graph, orbits);\n\n    let formula = encode_problem(\u0026quotient_graph, graph);\n\n    if let Some((formula, dict)) = formula {\n        if settings.validate {\n            let transversal_result = solve_validate(formula, dict);\n            if let Some(transversal) = transversal_result.unwrap() {\n                assert!(is_transversal_consistent(\n                    \u0026transversal,\n                    graph,\n                    quotient_graph.encode_high()\n                ));\n                true\n            } else {\n                false\n            }\n        } else {\n            solve(formula).unwrap()\n        }\n    } else {\n        true\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn main() -\u003e Result\u003c(), Error\u003e {\n    // Read the graph from a file or via CLI and ...\n    let (mut graph, mut settings) = read_graph()?;\n\n    if let Some(eval_buf) = settings.evaluate {\n        let logs = evaluate_log_file(\u0026mut eval_buf.lines());\n        evaluate_logs(logs);\n        return Ok(());\n    }\n\n    // Search for a non descriptive core in a single non-descriptive quotient.\n    if settings.nondescriptive_core.is_some() {\n        return search_with_core(\u0026mut graph, \u0026mut settings);\n    }\n\n    if settings.search_group {\n        let nauty_graph = NautyGraph::from_graph(\u0026mut graph);\n        assert!(nauty_graph.check_valid());\n\n        search_group(\u0026mut graph, nauty_graph, \u0026mut settings);\n        return Ok(());\n    }\n\n    // ... compute the generators with nauty or Traces. Then ...\n    let mut generators = compute_generators(\u0026mut graph, \u0026mut settings);\n\n    do_if_some(settings.get_stats(), Statistics::log_nauty_done);\n    do_if_some(settings.get_stats(), |st| {\n        st.log_number_of_generators(generators.len())\n    });\n\n    // Sort the graph to allow easier lookup for edges.\n    time!(graph_sort_time, _t, graph.sort());\n    do_if_some(settings.get_stats(), |stats| {\n        stats.log_graph_sorted(graph_sort_time)\n    });\n\n    if settings.gap_mode {\n        return gap_mode(\u0026graph, generators, settings.get_stats());\n    }\n\n    // ... iterate over the specified subsets of generators...\n    if settings.get_stats().is_some() {\n        // ... with statistics ...\n        if settings.iter_powerset {\n            generators\n                .into_iter()\n                .powerset()\n                .skip(1)\n                .find_map(|mut subset| {\n                    if compute_quotient_with_statistics(\u0026mut subset, \u0026graph, \u0026mut settings) {\n                        Some(())\n                    } else {\n                        None\n                    }\n                });\n        } else if !generators.is_empty() {\n            compute_quotient_with_statistics(\u0026mut generators, \u0026graph, \u0026mut settings);\n        }\n\n        do_if_some(settings.get_stats(), |statistics| {\n            statistics.exhausted = true;\n            statistics.log_end();\n            statistics.save_statistics().unwrap();\n        });\n    } else {\n        // ... or without.\n        if settings.iter_powerset {\n            generators\n                .into_iter()\n                .powerset()\n                .skip(1)\n                .find_map(|mut subset| {\n                    if compute_quotient(\u0026mut subset, \u0026graph, \u0026settings) {\n                        Some(())\n                    } else {\n                        None\n                    }\n                });\n        } else if !generators.is_empty() {\n            compute_quotient(\u0026mut generators, \u0026graph, \u0026settings);\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","metric.rs"],"content":"use crate::quotient::QuotientGraph;\n\npub trait Metric {\n    fn compare_quotients(left: \u0026QuotientGraph, right: \u0026QuotientGraph) -\u003e std::cmp::Ordering;\n}\n\n/// The quotient with the least number of orbits\n/// has the highest priority.\n#[derive(Debug)]\npub struct LeastOrbits;\nimpl Metric for LeastOrbits {\n    #[cfg(not(tarpaulin_include))]\n    fn compare_quotients(left: \u0026QuotientGraph, right: \u0026QuotientGraph) -\u003e std::cmp::Ordering {\n        left.quotient_graph.size().cmp(\u0026right.quotient_graph.size())\n    }\n}\n\n/// The quotient with the biggest maximum orbit size\n/// has the highest priority.\n#[derive(Debug)]\npub struct BiggestOrbits;\nimpl Metric for BiggestOrbits {\n    #[cfg(not(tarpaulin_include))]\n    fn compare_quotients(left: \u0026QuotientGraph, right: \u0026QuotientGraph) -\u003e std::cmp::Ordering {\n        let left_biggest = left.get_orbit_sizes().1;\n        let right_biggest = right.get_orbit_sizes().1;\n        left_biggest.cmp(\u0026right_biggest).reverse()\n    }\n}\n\n/// The sparsest quotient\n/// has the highest priority.\n#[derive(Debug)]\npub struct Sparsity;\nimpl Metric for Sparsity {\n    #[cfg(not(tarpaulin_include))]\n    fn compare_quotients(left: \u0026QuotientGraph, right: \u0026QuotientGraph) -\u003e std::cmp::Ordering {\n        let left_sparsity_coefficient =\n            left.quotient_graph.number_edges() as f64 / left.quotient_graph.size() as f64;\n        let right_sparsity_coefficient =\n            right.quotient_graph.number_edges() as f64 / right.quotient_graph.size() as f64;\n        left_sparsity_coefficient\n            .partial_cmp(\u0026right_sparsity_coefficient)\n            .expect(\"Sparsity coefficients should be comparable\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","misc.rs"],"content":"use std::{fs::File, io::BufReader, str::FromStr};\n\nuse crate::debug::MetricError;\nuse crate::statistics::Statistics;\nuse crate::{\n    metric::{BiggestOrbits, LeastOrbits, Metric, Sparsity},\n    quotient::QuotientGraph,\n};\n\n#[cfg(not(tarpaulin_include))]\n#[inline]\npub fn do_if_some\u003cF, T\u003e(optional: \u0026mut Option\u003cT\u003e, f: F)\nwhere\n    F: FnOnce(\u0026mut T),\n{\n    if let Some(val) = optional {\n        f(val);\n    }\n}\n\n#[derive(Debug)]\npub enum NautyTraces {\n    /// Calls dense nauty\n    Nauty,\n    /// Calls sparse nauty\n    SparseNauty,\n    /// Calls Traces (only for sparse graphs)\n    Traces,\n}\n\nimpl Default for NautyTraces {\n    fn default() -\u003e Self {\n        Self::Nauty\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum MetricUsed {\n    LeastOrbits,\n    BiggestOrbits,\n    Sparsity,\n    Standard,\n}\n\nimpl MetricUsed {\n    #[cfg(not(tarpaulin_include))]\n    pub fn compare_quotients(\n        \u0026self,\n        left: \u0026QuotientGraph,\n        right: \u0026QuotientGraph,\n    ) -\u003e std::cmp::Ordering {\n        use std::cmp::Ordering;\n\n        match \u0026self {\n            Self::LeastOrbits =\u003e LeastOrbits::compare_quotients(left, right),\n            Self::BiggestOrbits =\u003e BiggestOrbits::compare_quotients(left, right),\n            Self::Sparsity =\u003e Sparsity::compare_quotients(left, right),\n            Self::Standard =\u003e Ordering::Less,\n        }\n    }\n}\n\nimpl FromStr for MetricUsed {\n    type Err = MetricError;\n\n    #[cfg(not(tarpaulin_include))]\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if s == \"least_orbits\" {\n            Ok(Self::LeastOrbits)\n        } else if s == \"biggest_orbit\" {\n            Ok(Self::BiggestOrbits)\n        } else if s == \"sparsity\" {\n            Ok(Self::Sparsity)\n        } else if s == \"standard\" {\n            Ok(Self::Standard)\n        } else {\n            Err(MetricError(s.to_string()))\n        }\n    }\n}\n\nimpl Default for MetricUsed {\n    #[cfg(not(tarpaulin_include))]\n    fn default() -\u003e Self {\n        Self::Standard\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum CoreMetric {\n    Recolor,\n    PowerGenerators,\n    MergeGenerators,\n}\n\nimpl FromStr for CoreMetric {\n    type Err = MetricError;\n\n    #[cfg(not(tarpaulin_include))]\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s {\n            \"recolor\" =\u003e Ok(Self::Recolor),\n            \"pow_gen\" =\u003e Ok(Self::PowerGenerators),\n            \"merge_gen\" =\u003e Ok(Self::MergeGenerators),\n            _ =\u003e Err(MetricError(s.to_string())),\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Settings {\n    /// Iterate the whole powerset.\n    pub iter_powerset: bool,\n    /// Outputs orbits in dreadnaut format.\n    pub output_orbits: bool,\n    /// Log orbit sizes.\n    pub log_orbits: bool,\n    /// Print formula instead of solving it.\n    pub print_formula: bool,\n    /// Graph is colored and colors should be\n    /// included in the nauty computation.\n    pub colored_graph: bool,\n    /// Search for the smallest non-descriptive quotient\n    /// core in the first non-descriptive quotient graph.\n    pub nondescriptive_core: Option\u003cCoreMetric\u003e,\n    /// Search in the whole automorphism group instead\n    /// of a set of generators.\n    pub search_group: bool,\n    /// Validate each descriptiveness result\n    /// with exhaustive search for consistent\n    /// transversals.\n    pub validate: bool,\n    /// Operate in GAP mode.\n    /// This means that DQG use GAP to\n    /// search in the conjugacy classes.\n    pub gap_mode: bool,\n    /// Use the given metric to find the \"best\" quotient\n    /// and use it as described by the other flags.\n    pub metric: Option\u003cMetricUsed\u003e,\n    /// Evaluate a log file as printed by\n    /// the quotientPlanning tool.\n    pub evaluate: Option\u003cBufReader\u003cFile\u003e\u003e,\n    ///  Call nauty or traces.\n    pub nauyt_or_traces: NautyTraces,\n    /// Statistics object if used\n    pub statistics: Option\u003cStatistics\u003e,\n}\n\nimpl Settings {\n    pub fn get_stats(\u0026mut self) -\u003e \u0026mut Option\u003cStatistics\u003e {\n        \u0026mut self.statistics\n    }\n}\n","traces":[{"line":33,"address":[621136],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":150,"address":[622000],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","__w","dqg","dqg","src","parser","csv_parser.rs"],"content":"//! Parser for graphs encoded in csv files.\n\nuse std::io::BufRead;\n\nuse crate::{\n    get_line_recognize,\n    graph::{Graph, VertexIndex},\n    parse_single_line, Error,\n};\n\nuse super::{Input, ParseResult};\n\nfn parse_edge(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, (VertexIndex, VertexIndex)\u003e {\n    use nom::{\n        character::complete::{char, i32},\n        sequence::separated_pair,\n    };\n\n    separated_pair(i32, char(','), i32)(input)\n}\n\nfn parse_column_header(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, ()\u003e {\n    use nom::{character::complete::not_line_ending, combinator::value};\n\n    value((), not_line_ending)(input)\n}\n\npub fn parse_csv_input\u003cB: BufRead\u003e(graph_size: usize, input: B) -\u003e Result\u003cGraph, Error\u003e {\n    use nom::combinator::eof;\n\n    let mut graph = Graph::new_ordered(graph_size);\n    let mut lines = input.lines();\n\n    get_line_recognize!(lines, parse_column_header);\n\n    for line in lines {\n        let line = line?;\n        parse_single_line!(start_end, parse_edge(\u0026line));\n        let (start, end) = start_end;\n        graph\n            .add_edge(start, end)\n            .expect(\"Edge to non existing vertex! Graph too small!\");\n    }\n\n    Ok(graph)\n}\n\n#[cfg(test)]\nmod test {\n    use std::io::BufReader;\n\n    use crate::Error;\n\n    use super::*;\n\n    #[test]\n    fn test_parse_edge() -\u003e Result\u003c(), Error\u003e {\n        let edge = \"123,46783\";\n        let parsed = parse_edge(edge)?.1;\n        assert_eq!((123, 46783), parsed);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_column_header() -\u003e Result\u003c(), Error\u003e {\n        let header = \"node_1,node_2\\n\";\n        Ok(parse_column_header(header)?.1)\n    }\n\n    #[test]\n    fn test_parse_csv_input() -\u003e Result\u003c(), Error\u003e {\n        let csv = \"node_1,node_2\n0,3\n0,1\n0,6\n1,10\n1,3\n\";\n        let buf = BufReader::new(csv.as_bytes());\n        let parsed = parse_csv_input(11, buf)?;\n\n        let mut graph = Graph::new_ordered(11);\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 6)?;\n        graph.add_edge(1, 10)?;\n        graph.add_edge(1, 3)?;\n\n        assert_eq!(graph, parsed);\n\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[643360],"length":1,"stats":{"Line":1},"fn_name":"parse_edge"},{"line":19,"address":[643393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[643472],"length":1,"stats":{"Line":1},"fn_name":"parse_column_header"},{"line":25,"address":[643505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1533836,1531792,1533984,1536011,1536140,1533959],"length":1,"stats":{"Line":1},"fn_name":"parse_csv_input\u003cstd::io::buffered::bufreader::BufReader\u003c\u0026[u8]\u003e\u003e"},{"line":31,"address":[1534104,1534014,1531822,1531912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1531920,1532036,1534219,1534112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[1536057,1534569,1536041,1533866,1533882,1534900,1532102,1534288,1532727,1534243,1532383,1532057],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[1536004,1534957,1532784,1532630,1534816,1533829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1533845,1533249,1532955,1535293,1533120,1536020,1535422,1535128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[1533798,1535400,1533344,1533689,1533819,1535863,1535994,1535517,1533227,1535973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[1535824,1533651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1533670,1533750,1535843,1535925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1532990,1535163],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":15},{"path":["/","__w","dqg","dqg","src","parser","dre_parser.rs"],"content":"//! Parser for graph files in dreadnaut syntax.\n//! E.g., these can be generated from planning\n//! problems by this tool: \u003chttps://home.in.tum.de/~mansour/cv-and-website/tools/quotientPlan.zip\u003e\n\nuse std::{io::BufRead, iter::Peekable};\n\nuse nom::error::ParseError;\n\nuse crate::{\n    get_line, get_line_parse,\n    graph::{Colour, Graph, VertexIndex, DEFAULT_COLOR},\n    parse_single_line, Error,\n};\n\nuse super::{Input, ParseResult};\n\n/// The used graph generation tool writes always this header first.\n/// This only encodes that Traces should print out information which\n/// this tool doesn't need due to it using nauty/Traces as a library.\nfn parse_header\u003cI\u003e(input: \u0026mut Peekable\u003cI\u003e) -\u003e ParseResult\u003c'_, ()\u003e\nwhere\n    I: Iterator\u003cItem = Result\u003cString, std::io::Error\u003e\u003e,\n{\n    use nom::{\n        bytes::complete::tag,\n        error::{ErrorKind, VerboseError},\n        Err,\n    };\n\n    let empty_peek = |line: \u0026std::io::Result\u003cString\u003e| {\n        let line = line.as_ref();\n        if let Ok(line) = line {\n            line == \u0026\"\".to_string()\n        } else {\n            false\n        }\n    };\n    let tag_peek = |tag_name| {\n        move |line: \u0026std::io::Result\u003cString\u003e| {\n            let line = line.as_ref();\n            if let Ok(line) = line {\n                tag::\u003c\u0026str, \u0026str, ()\u003e(tag_name)(line).is_ok()\n            } else {\n                false\n            }\n        }\n    };\n    let empty_err = Err::Error(VerboseError::from_error_kind(\"\", ErrorKind::CrLf));\n    let tag_err = |tag| Err::Error(VerboseError::from_error_kind(tag, ErrorKind::Tag));\n\n    let _ = input.next_if(tag_peek(\"At\")).ok_or_else(|| tag_err(\"At\"))?;\n    let _ = input.next_if(empty_peek).ok_or(empty_err)?;\n    let _ = input.next_if(tag_peek(\"-a\")).ok_or_else(|| tag_err(\"-a\"))?;\n    let _ = input.next_if(tag_peek(\"-m\")).ok_or_else(|| tag_err(\"-m\"))?;\n\n    Ok((\"\", ()))\n}\n\n/// Parse the start line for th graph that contains the size.\nfn parse_graph_size(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, usize\u003e {\n    use nom::{bytes::complete::tag, character::complete::u64, error::context, sequence::tuple};\n\n    let mut size_header = context(\"Graph size header\", tuple((tag(\"n=\"), u64, tag(\" g\"))));\n    let (rest, (_, graph_size, _)) = size_header(input)?;\n    Ok((rest, graph_size as usize))\n}\n\n/// Parse a single vertex index.\nfn parse_vertex_index(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, VertexIndex\u003e {\n    use nom::character::complete::i32;\n    i32(input)\n}\n\n/// Parse the edges from vertex s from `s:e1 e2 e3 ... en`.\nfn parse_vertex_edges(\n    graph_size: usize,\n    input: Input\u003c'_\u003e,\n) -\u003e ParseResult\u003c'_, (VertexIndex, Vec\u003cVertexIndex\u003e)\u003e {\n    use nom::{\n        bytes::complete::tag,\n        character::complete::{space0, space1},\n        combinator::verify,\n        error::context,\n        multi::separated_list1,\n        sequence::pair,\n    };\n\n    let (input, index) = context(\"lines starts with vector index\", parse_vertex_index)(input)?;\n    let (input, _) = pair(tag(\":\"), space0)(input)?;\n\n    let (rest, edges) = context(\n        \"List of edges from this vertex\",\n        separated_list1(\n            space1,\n            verify(parse_vertex_index, |end_index| {\n                *end_index \u003c graph_size as VertexIndex \u0026\u0026 *end_index != index\n            }),\n        ),\n    )(input)?;\n\n    Ok((rest, (index, edges)))\n}\n\n/// Parse the end of a edge line which determines\n/// if the edge_lines stop early (`.`) or continues (`;`).\nfn parse_continue_after_edge_line(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, bool\u003e {\n    use nom::{\n        branch::alt, bytes::complete::tag, character::complete::space0, combinator::map,\n        sequence::preceded,\n    };\n\n    let edge_list_end = preceded(space0, alt((tag(\";\"), tag(\".\"))));\n    let mut should_continue_after_line = map(edge_list_end, |end: \u0026str| end == \";\");\n\n    should_continue_after_line(input)\n}\n\n/// Parse the colouring (i.e. the partition of the vertices). The input looks like this:\n/// `f=[c11,c12.c13,...c1n|c21,c22,...c2m|...|cp1,cp2,...,cpk]`\n/// Not specified vertices stay in colour DEFAULT_COLOR.\n/// Also checks, that there is nothing of relevance after the colouring.\nfn parse_colouring(graph_size: usize, input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, (Vec\u003cColour\u003e, Colour)\u003e {\n    use nom::{\n        bytes::complete::tag,\n        character::complete::{multispace1, space0},\n        combinator::opt,\n        multi::{separated_list0, separated_list1},\n        sequence::tuple,\n    };\n\n    let mut colours = vec![DEFAULT_COLOR; graph_size];\n    let mut colour_counter = 1;\n\n    let sep = |sep_tag| tuple((space0, tag(sep_tag), space0));\n\n    let single_colour = separated_list1(sep(\",\"), parse_vertex_index);\n    let mut colour_list = separated_list0(sep(\"|\"), single_colour);\n\n    let (input, _) = tag(\"f=[\")(input)?;\n    let (input, colour_list) = colour_list(input)?;\n    let (rest, _) = tuple((tag(\"]\"), opt(tag(\" x o\")), opt(multispace1)))(input)?;\n\n    for colour in colour_list {\n        for vertex in colour {\n            colours[vertex as usize] = colour_counter;\n        }\n        colour_counter += 1;\n    }\n\n    Ok((rest, (colours, colour_counter)))\n}\n\npub fn parse_dreadnaut_input\u003cB: BufRead\u003e(input: B) -\u003e Result\u003c(Graph, bool), Error\u003e {\n    use nom::combinator::eof;\n\n    let mut lines = input.lines().peekable();\n\n    let header = parse_header(\u0026mut lines).is_ok();\n    get_line_parse!(lines, graph_size, parse_graph_size);\n\n    let mut graph = Graph::new_ordered(graph_size);\n\n    loop {\n        get_line!(line, lines);\n        let (res, vertex_edges) = parse_vertex_edges(graph_size, \u0026line)?;\n        let (vertex, edges) = vertex_edges;\n\n        for end in edges {\n            graph.add_edge(vertex, end)?;\n        }\n\n        parse_single_line!(should_continue, parse_continue_after_edge_line(res));\n\n        if !should_continue || vertex as usize \u003e= graph_size - 1 {\n            break;\n        }\n    }\n\n    get_line!(color_line, lines);\n    parse_single_line!(colours, parse_colouring(graph_size, \u0026color_line));\n    let (colours, max_colour) = colours;\n    graph.set_colours(\u0026colours)?;\n    graph.update_max_color(max_colour);\n\n    Ok((graph, header))\n}\n\n#[cfg(test)]\nmod test {\n    use std::io::BufReader;\n\n    use super::*;\n\n    #[test]\n    fn test_parse_header() -\u003e Result\u003c(), Error\u003e {\n        let test_input = \"At\n\n-a\n-m\n\";\n        let test_buf = BufReader::new(test_input.as_bytes());\n        let mut test_lines = test_buf.lines().peekable();\n        Ok(parse_header(\u0026mut test_lines)?.1)\n    }\n\n    #[test]\n    fn test_parse_graph_size() -\u003e Result\u003c(), Error\u003e {\n        let test_size = 128;\n\n        let valid_input = format!(\"n={} g\\n\", test_size);\n        let (_, parsed_size) = parse_graph_size(\u0026valid_input)?;\n        assert_eq!(test_size, parsed_size);\n\n        let non_ternary_input = \"n=0xfa g\\n\";\n        assert!(parse_graph_size(non_ternary_input).is_err());\n\n        let leading_zeros_input = format!(\"n=0000{} g\\n\", test_size);\n        let (_, parsed_size) = parse_graph_size(\u0026leading_zeros_input)?;\n        assert_eq!(test_size, parsed_size);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_vertex_index() -\u003e Result\u003c(), Error\u003e {\n        let test_index = 15632;\n\n        let test_input = format!(\"{}\", test_index);\n        let (_, parsed_index) = parse_vertex_index(\u0026test_input)?;\n        assert_eq!(test_index, parsed_index);\n\n        let negative_input = format!(\"-{}\", test_index);\n        let (_, negative_parsed_index) = parse_vertex_index(\u0026negative_input)?;\n        assert_eq!(-test_index, negative_parsed_index);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_vertex_edges() -\u003e Result\u003c(), Error\u003e {\n        let test_input = \"12345:12 2 0 12 34235 88 23 ;\";\n        let test_size = i32::MAX;\n\n        let (_, (vertex, edges)) = parse_vertex_edges(test_size as usize, test_input)?;\n        assert_eq!(12345, vertex);\n        assert_eq!(vec![12, 2, 0, 12, 34235, 88, 23], edges);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_continue_after_edge_line() -\u003e Result\u003c(), Error\u003e {\n        let continue_input = \"      ;\\n\";\n        let (_, parsed_flag) = parse_continue_after_edge_line(continue_input)?;\n        assert!(parsed_flag);\n\n        let quit_input = \" .\\n \";\n        let (_, parsed_flag) = parse_continue_after_edge_line(quit_input)?;\n        assert!(!parsed_flag);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_colouring() -\u003e Result\u003c(), Error\u003e {\n        let test_input = \"f=[1|  0  ,  3 | 2] x o\\n\\n\";\n        let (_, (parsed_colours, max_colour)) = parse_colouring(5, test_input)?;\n        assert_eq!(4, max_colour);\n        assert_eq!(vec![2, 1, 3, 2, DEFAULT_COLOR], parsed_colours);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_dreadnaut_input() -\u003e Result\u003c(), Error\u003e {\n        let test_file = \"At\n\n-a\n-m\nn=4 g\n0:1 2 ;\n2:3;\n3:0.\nf=[0|1, 2] x o\n\n        \";\n        let test_buf = BufReader::new(test_file.as_bytes());\n        let mut expected_graph = Graph::new_ordered(4);\n        expected_graph.add_edge(0, 1)?;\n        expected_graph.add_edge(0, 2)?;\n        expected_graph.add_edge(2, 3)?;\n        expected_graph.add_edge(3, 0)?;\n        expected_graph.set_colours(\u0026vec![1, 2, 2, DEFAULT_COLOR])?;\n        expected_graph.update_max_color(3);\n\n        let (parsed_graph, has_header) = parse_dreadnaut_input(test_buf)?;\n        assert_eq!(expected_graph, parsed_graph);\n        assert!(has_header);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_dreadnaut_input_wo_header() -\u003e Result\u003c(), Error\u003e {\n        let test_file = \"n=4 g\n0:1 2 ;\n2:3;\n3:0.\nf=[0|1, 2] \n\n        \";\n        let test_buf = BufReader::new(test_file.as_bytes());\n        let mut expected_graph = Graph::new_ordered(4);\n        expected_graph.add_edge(0, 1)?;\n        expected_graph.add_edge(0, 2)?;\n        expected_graph.add_edge(2, 3)?;\n        expected_graph.add_edge(3, 0)?;\n        expected_graph.set_colours(\u0026vec![1, 2, 2, DEFAULT_COLOR])?;\n        expected_graph.update_max_color(3);\n\n        let (parsed_graph, has_header) = parse_dreadnaut_input(test_buf)?;\n        assert_eq!(expected_graph, parsed_graph);\n        assert!(!has_header);\n\n        Ok(())\n    }\n}\n","traces":[{"line":20,"address":[1330412,1332021,1330448,1328864,1331996,1332032,1333580,1333605,1330437],"length":1,"stats":{"Line":2},"fn_name":"parse_header\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e\u003e"},{"line":30,"address":[1333616,1328894,1330478,1332062,1334013,1333805,1334032,1334221,1333824],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e\u003e"},{"line":31,"address":[1333643,1333851,1334059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1333866,1333736,1333658,1334074,1333944,1334152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1333676,1333982,1334190,1333774,1333884,1334092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1333731,1333939,1334147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1334288,1334336,1334240],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003c\u0026[u8]\u003e\u003e\u003e"},{"line":39,"address":[1334255,1334576,1334768,1334351,1334303,1334384],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e\u003e"},{"line":40,"address":[1334803,1334419,1334611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1334434,1334626,1334818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1334848,1334464,1334656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1334548,1334740,1334932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1328902,1330486,1332070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1335141,1335013,1335755,1335995,1332054,1335835,1335675,1335595,1330470,1335088,1335435,1335269,1335515,1334960,1335216,1335915,1335355,1328886],"length":1,"stats":{"Line":5},"fn_name":"{closure#2}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003c\u0026[u8]\u003e\u003e\u003e"},{"line":51,"address":[1332147,1330388,1331972,1335424,1335520,1335504,1333556,1329108,1335360,1332276,1335344,1330692,1328979,1330563,1335440],"length":1,"stats":{"Line":7},"fn_name":"{closure#3}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003cstd::io::stdio::StdinLock\u003e\u003e\u003e"},{"line":52,"address":[1330949,1332533,1331970,1330386,1333554,1329365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1331211,1335760,1332795,1335584,1335600,1333552,1330384,1331968,1329627,1335664,1335680,1335744],"length":1,"stats":{"Line":1},"fn_name":"{closure#4}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e\u003e"},{"line":54,"address":[1333538,1335840,1330370,1335920,1333127,1335824,1329959,1335904,1335984,1331954,1336000,1331543],"length":1,"stats":{"Line":1},"fn_name":"{closure#5}\u003cstd::io::Lines\u003cstd::io::buffered::bufreader::BufReader\u003cstd::io::stdio::StdinLock\u003e\u003e\u003e"},{"line":56,"address":[1333459,1331875,1330291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[914176],"length":1,"stats":{"Line":2},"fn_name":"parse_graph_size"},{"line":63,"address":[914218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[914359,914614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[914541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[914720],"length":1,"stats":{"Line":1},"fn_name":"parse_vertex_index"},{"line":71,"address":[914741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[914768],"length":1,"stats":{"Line":2},"fn_name":"parse_vertex_edges"},{"line":88,"address":[914816,915219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[915296,915049,915556],"length":1,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[915760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[916048],"length":1,"stats":{"Line":1},"fn_name":"parse_continue_after_edge_line"},{"line":112,"address":[916091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1336162,1336144],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":115,"address":[916237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[918791,916304,918872],"length":1,"stats":{"Line":1},"fn_name":"parse_colouring"},{"line":131,"address":[916373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[916419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[916349],"length":1,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[916561,916430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[916638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[916759,917058,918870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[917323,916995,917131,918868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[917283,917444,917900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[917957,917829,918738],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[918182,918786,918477],"length":1,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[918671,918784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[918709,918743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[918210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1344592,1348727,1344217,1344567,1340432,1348377,1340407,1340057,1336272],"length":1,"stats":{"Line":2},"fn_name":"parse_dreadnaut_input\u003cstd::io::buffered::bufreader::BufReader\u003cstd::io::stdio::StdinLock\u003e\u003e"},{"line":156,"address":[1344615,1340455,1336295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[1336440,1344705,1336385,1340545,1340600,1344760],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[1348725,1340405,1336538,1344565,1341322,1345482,1340383,1341001,1340698,1344858,1345161,1348703,1337162,1344543,1336841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[1337219,1341379,1345539,1341307,1337147,1345467],"length":1,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[1344493,1340333,1345563,1348653,1341451,1337291,1341646,1337243,1345611,1341403,1345806,1337486],"length":1,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[1340331,1341615,1337859,1344491,1345775,1345915,1337455,1348651,1337595,1341755,1342019,1346179],"length":1,"stats":{"Line":4},"fn_name":null},{"line":166,"address":[1346090,1341930,1337770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[1342004,1337957,1344440,1340280,1342117,1346164,1337844,1348600,1346277],"length":1,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[1346480,1342320,1340182,1338160,1348502,1344342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[1338530,1340172,1346516,1344320,1342356,1344332,1340160,1348480,1346850,1342690,1338196,1348492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[1342676,1346946,1342786,1346836,1338516,1338626],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[1348478,1347268,1347072,1340158,1342912,1338948,1343108,1338752,1344318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[1340138,1340066,1347818,1344298,1339353,1347673,1339051,1343083,1348386,1348458,1339498,1344226,1343211,1347243,1347371,1343658,1338923,1343513],"length":1,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[1339403,1343563,1347723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[1347937,1343877,1347781,1339717,1339461,1339617,1343777,1343621,1348037],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[1339702,1348022,1343862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1343923,1348083,1339763],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":63,"coverable":67},{"path":["/","__w","dqg","dqg","src","parser","mod.rs"],"content":"mod csv_parser;\nmod dre_parser;\nmod mus_parser;\nmod txt_parser;\n\npub use csv_parser::parse_csv_input;\npub use dre_parser::parse_dreadnaut_input;\npub use mus_parser::{BinInput, BinParseError, BinParseResult, _parse_mus};\npub use txt_parser::parse_txt_input;\n\npub type Input\u003c'a\u003e = \u0026'a str;\npub type ParseError\u003c'a\u003e = nom::error::VerboseError\u003cInput\u003c'a\u003e\u003e;\npub type ParseResult\u003c'a, O\u003e = nom::IResult\u003cInput\u003c'a\u003e, O, ParseError\u003c'a\u003e\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","parser","mus_parser.rs"],"content":"//! Parser for the output of picomus and similar MUS solver.\n\nuse crate::Error;\n\npub type BinInput\u003c'a\u003e = \u0026'a [u8];\npub type BinParseError\u003c'a\u003e = nom::error::VerboseError\u003cBinInput\u003c'a\u003e\u003e;\npub type BinParseResult\u003c'a, O\u003e = nom::IResult\u003cBinInput\u003c'a\u003e, O, BinParseError\u003c'a\u003e\u003e;\n\nfn _parse_comment(input: BinInput\u003c'_\u003e) -\u003e BinParseResult\u003c'_, ()\u003e {\n    use nom::{\n        character::complete::{char, line_ending, not_line_ending},\n        combinator::value,\n        error::context,\n        multi::many_till,\n        sequence::terminated,\n    };\n\n    context(\n        \"MUS Comment line\",\n        value(\n            (),\n            terminated(char('c'), many_till(not_line_ending, line_ending)),\n        ),\n    )(input)\n}\n\nfn _parse_unsat(input: BinInput\u003c'_\u003e) -\u003e BinParseResult\u003c'_, ()\u003e {\n    use nom::{\n        bytes::complete::tag, character::complete::line_ending, combinator::value, error::context,\n        sequence::pair,\n    };\n\n    context(\n        \"MUS UNSAT result line\",\n        value((), pair(tag(\"s UNSATISFIABLE\"), line_ending)),\n    )(input)\n}\n\nfn _parse_clause_number(input: BinInput\u003c'_\u003e) -\u003e BinParseResult\u003c'_, usize\u003e {\n    use nom::{\n        bytes::complete::tag,\n        character::complete::{line_ending, u64},\n        combinator::map,\n        error::context,\n        sequence::{preceded, terminated},\n    };\n\n    context(\n        \"MUS core clause line\",\n        map(\n            terminated(preceded(tag(\"v \"), u64), line_ending),\n            |clause| clause as usize,\n        ),\n    )(input)\n}\n\n/// Parse output of picomus and return core as clause indices.\npub fn _parse_mus(input: BinInput\u003c'_\u003e) -\u003e Result\u003cVec\u003cusize\u003e, Error\u003e {\n    use nom::{\n        branch::alt,\n        combinator::eof,\n        error::context,\n        multi::{fold_many0, many1},\n    };\n\n    let uninteresting = alt((_parse_comment, _parse_unsat));\n    let mut skip = context(\n        \"Comment and UNSAT lines\",\n        fold_many0(uninteresting, || (), |_, _| ()),\n    );\n\n    let mut core_clauses = context(\"Clauses in core\", many1(_parse_clause_number));\n\n    let (res, _) = skip(input)?;\n    let (res, mut core) = core_clauses(res)?;\n    eof::\u003cBinInput\u003c'_\u003e, BinParseError\u003c'_\u003e\u003e(res)?;\n\n    let last = core.pop();\n    assert_eq!(\n        last,\n        Some(0),\n        \"Last core clause not 0! Picomus output not complete!\"\n    );\n    Ok(core)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_comment() -\u003e Result\u003c(), Error\u003e {\n        let comment = b\"c whatever is written here, I don't really care lul \\n\";\n\n        _parse_comment(comment)?;\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_unsat() -\u003e Result\u003c(), Error\u003e {\n        let unsat = b\"s UNSATISFIABLE\\n\";\n\n        _parse_unsat(unsat)?;\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_clause_number() -\u003e Result\u003c(), Error\u003e {\n        let clause = b\"v 131\\n\";\n\n        let (_, clause_number) = _parse_clause_number(clause)?;\n        assert_eq!(131, clause_number);\n\n        let clause = b\"v 0\\n\";\n\n        let (_, clause_number) = _parse_clause_number(clause)?;\n        assert_eq!(0, clause_number);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_mus() -\u003e Result\u003c(), Error\u003e {\n        let mus = b\"c [picomus] WARNING: no output file given\ns UNSATISFIABLE\nc [picomus] computed MUS of size 17 out of 814 (2%)\nv 20\nv 36\nv 80\nv 96\nv 156\nv 158\nv 168\nv 170\nv 650\nv 652\nv 669\nv 671\nv 680\nv 700\nv 707\nv 725\nv 734\nv 0\n\";\n\n        let clauses = _parse_mus(mus)?;\n        let expected_clauses = vec![\n            20, 36, 80, 96, 156, 158, 168, 170, 650, 652, 669, 671, 680, 700, 707, 725, 734,\n        ];\n\n        assert_eq!(expected_clauses, clauses);\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[806976],"length":1,"stats":{"Line":1},"fn_name":"_parse_comment"},{"line":27,"address":[807136],"length":1,"stats":{"Line":1},"fn_name":"_parse_unsat"},{"line":39,"address":[807296],"length":1,"stats":{"Line":1},"fn_name":"_parse_clause_number"},{"line":58,"address":[808713,807472],"length":1,"stats":{"Line":1},"fn_name":"_parse_mus"},{"line":66,"address":[807499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[807520],"length":1,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[807552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[807600,807832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[807740,808050,807915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[808199,808283,808035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[808249,808350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[808374,808600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[808499],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","__w","dqg","dqg","src","parser","txt_parser.rs"],"content":"//! Parser for graphs in a specific format.\n//! The supported format is based of data from\n//! https://snap.stanford.edu/data/ .\n\nuse std::io::BufRead;\n\nuse crate::{\n    get_line_parse, get_line_recognize,\n    graph::{Graph, VertexIndex},\n    parse_single_line, Error,\n};\n\nuse super::{Input, ParseResult};\n\nfn parse_size_comment(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, usize\u003e {\n    use nom::{\n        bytes::complete::tag,\n        character::complete::{char, u64},\n        combinator::map,\n        sequence::{preceded, terminated, tuple},\n    };\n\n    let size_parser = preceded(tag(\" Nodes: \"), u64);\n    let edges_parser = tuple((tag(\" Edges: \"), u64));\n    let comment_parser = preceded(char('#'), terminated(size_parser, edges_parser));\n\n    map(comment_parser, |size| size as usize)(input)\n}\n\nfn parse_meaningless_comment(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, ()\u003e {\n    use nom::{\n        character::complete::{char, not_line_ending},\n        combinator::value,\n        sequence::tuple,\n    };\n\n    let comment_line_parser = tuple((char('#'), not_line_ending));\n    value((), comment_line_parser)(input)\n}\n\nfn parse_edge(input: Input\u003c'_\u003e) -\u003e ParseResult\u003c'_, (VertexIndex, VertexIndex)\u003e {\n    use nom::{\n        character::complete::{i32, multispace1},\n        sequence::{pair, terminated},\n    };\n\n    pair(terminated(i32, multispace1), i32)(input)\n}\n\npub fn parse_txt_input\u003cB: BufRead\u003e(input: B) -\u003e Result\u003cGraph, Error\u003e {\n    use nom::combinator::eof;\n\n    let mut lines = input.lines().peekable();\n\n    get_line_recognize!(lines, parse_meaningless_comment);\n    get_line_recognize!(lines, parse_meaningless_comment);\n    get_line_parse!(lines, graph_size, parse_size_comment);\n    get_line_recognize!(lines, parse_meaningless_comment);\n\n    let mut graph = Graph::new_ordered(graph_size);\n\n    for line in lines {\n        let line = line?;\n        parse_single_line!(start_end, parse_edge(\u0026line));\n        let (start, end) = start_end;\n\n        graph\n            .add_edge(start, end)\n            .expect(\"Edge to non existing vertex! Graph too small!\");\n    }\n\n    Ok(graph)\n}\n\n#[cfg(test)]\nmod test {\n    use std::io::BufReader;\n\n    use crate::Error;\n\n    use super::*;\n\n    #[test]\n    fn test_parse_size_comment() -\u003e Result\u003c(), Error\u003e {\n        let comment = \"# Nodes: 18772 Edges: 396160\\n\";\n        let (_, parsed) = parse_size_comment(comment)?;\n        assert_eq!(18772, parsed);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_parse_meaningless_comment() -\u003e Result\u003c(), Error\u003e {\n        let comment = \"# Directed graph (each unordered pair of nodes is saved once):\\n\";\n        Ok(parse_meaningless_comment(comment)?.1)\n    }\n\n    #[test]\n    fn test_parse_txt_input() -\u003e Result\u003c(), Error\u003e {\n        let txt = \"# Directed graph (each unordered pair of nodes is saved once): CA-AstroPh.txt \n# Collaboration network of Arxiv Astro Physics category (there is an edge if authors coauthored at least one paper)\n# Nodes: 6 Edges: 396160\n# FromNodeId\tToNodeId\n0\t1\n2\t3\n1\t4\n2\t5\n\";\n        let buf = BufReader::new(txt.as_bytes());\n        let mut graph = Graph::new_ordered(6);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(1, 4)?;\n        graph.add_edge(2, 5)?;\n\n        let parsed = parse_txt_input(buf)?;\n\n        assert_eq!(graph, parsed);\n\n        Ok(())\n    }\n}\n","traces":[{"line":15,"address":[1349472],"length":1,"stats":{"Line":1},"fn_name":"parse_size_comment"},{"line":23,"address":[1349515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1349568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1349636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[996464,996477],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":30,"address":[1349808],"length":1,"stats":{"Line":1},"fn_name":"parse_meaningless_comment"},{"line":37,"address":[1349842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1349871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1349936],"length":1,"stats":{"Line":1},"fn_name":"parse_edge"},{"line":47,"address":[1349969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1000360,1000560,996480,1004440,1004606,1000526],"length":1,"stats":{"Line":1},"fn_name":"parse_txt_input\u003cstd::io::buffered::bufreader::BufReader\u003cstd::fs::File\u003e\u003e"},{"line":53,"address":[996497,1000577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[996573,996621,997177,1000480,1001257,1004560,1000653,1000496,1000701,1004576,996902,1000982],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[1001595,1004558,1000455,997515,1001870,1001245,1004535,997790,1001314,1000478,997234,997165],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[997778,1002208,998440,1001927,1001858,1002520,997847,998128,1000430,1000453,1004510,1004533],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[1002858,1000428,1002577,1003130,998497,998778,1004485,998428,999050,1000405,1004508,1002508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[999038,1003118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[999258,999107,1003187,1003338,1004433,1000353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[1000369,999426,999641,1003506,999770,1003721,1003850,1004449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[1000322,1000343,1004423,1004402,999748,1003828,1000213,1004293,1003945,999865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[1000172,1004252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1004354,1000194,1000274,1004274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1003541,999461],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","__w","dqg","dqg","src","permutation.rs"],"content":"use std::convert::TryInto;\n\nuse itertools::Itertools;\n#[cfg(test)]\nuse num::Integer;\n\nuse crate::graph::VertexIndex;\n\n#[derive(Debug)]\npub struct IncompatiblePermutationSizes;\n\n#[derive(Debug, Clone, PartialOrd, Ord)]\npub struct Permutation {\n    pub raw: Vec\u003cVertexIndex\u003e,\n    cycles: Option\u003cVec\u003cVec\u003cVertexIndex\u003e\u003e\u003e,\n}\n\nimpl PartialEq for Permutation {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.raw.eq(\u0026other.raw)\n    }\n}\n\nimpl Eq for Permutation {}\n\nimpl Permutation {\n    /// Builds a new permutation from the given vector but doesn't\n    /// compute the cycles explicitly.\n    pub fn new(raw: Vec\u003cVertexIndex\u003e) -\u003e Self {\n        Permutation { raw, cycles: None }\n    }\n\n    /// Builds a new permutation from the given vector and\n    /// compute the cycles explicitly.\n    pub fn new_with_cycles(raw: Vec\u003cVertexIndex\u003e) -\u003e Self {\n        let mut new = Permutation { raw, cycles: None };\n        new.compute_cycles();\n        new\n    }\n\n    /// Builds a new permutation form the given cycles.\n    /// The cycles need not contain single element cycles as well.\n    pub fn from_cycles(cycles: Vec\u003cVec\u003cVertexIndex\u003e\u003e, size: usize) -\u003e Self {\n        let mut raw = (0..size as VertexIndex).collect_vec();\n\n        for cycle in cycles.iter().filter(|cycle| cycle.len() \u003e 1) {\n            Self::from_cycle(cycle, \u0026mut raw);\n        }\n\n        let cycles = cycles.into_iter().filter(|cycle| cycle.len() \u003e 1).collect();\n\n        Permutation {\n            raw,\n            cycles: Some(cycles),\n        }\n    }\n\n    /// Standard composition of permutations where the right\n    /// permutation is applied first (i.e. the inner one).\n    ///\n    /// (x . y)(a) = x(y(a))\n    pub fn compose(left: \u0026Self, right: \u0026Self) -\u003e Result\u003cSelf, IncompatiblePermutationSizes\u003e {\n        if left.len() != right.len() {\n            return Err(IncompatiblePermutationSizes);\n        }\n\n        let mut compositum = Permutation {\n            cycles: None,\n            ..right.clone()\n        };\n        compositum.compose_with(left)?;\n\n        Ok(compositum)\n    }\n\n    pub fn merge(self, other: Self) -\u003e Result\u003cSelf, IncompatiblePermutationSizes\u003e {\n        Self::compose(\u0026other, \u0026self)\n    }\n\n    /// Composes another permutation with this permutation.\n    /// The other permutation is the subsequent one.\n    ///\n    /// In-place version of [`Permutation::compose`].\n    pub fn compose_with(\n        \u0026mut self,\n        subsequent_perm: \u0026Self,\n    ) -\u003e Result\u003c(), IncompatiblePermutationSizes\u003e {\n        if self.len() != subsequent_perm.len() {\n            return Err(IncompatiblePermutationSizes);\n        }\n\n        for value in self.raw.iter_mut() {\n            let self_index: usize = *value as usize;\n            let subsequent_value = subsequent_perm.get(self_index).unwrap();\n            *value = *subsequent_value;\n        }\n\n        Ok(())\n    }\n\n    #[cfg(test)]\n    pub fn nth_power(\u0026mut self, n: usize) {\n        let self_copy = self.clone();\n\n        for _ in 1..n {\n            self.compose_with(\u0026self_copy).unwrap();\n        }\n    }\n\n    pub fn nth_power_of(\u0026self, n: usize) -\u003e Self {\n        let mut self_copy = self.clone();\n\n        for _ in 1..n {\n            self_copy.compose_with(self).unwrap();\n        }\n\n        self_copy\n    }\n\n    #[cfg(test)]\n    pub fn _nth_power_mod(\u0026mut self, mut n: usize) {\n        let order = self.get_order();\n        n %= order;\n        self.nth_power(n);\n    }\n\n    #[cfg(test)]\n    pub fn nth_power_of_mod(\u0026self, mut n: usize) -\u003e Self {\n        let mut self_copy = self.clone();\n\n        let order = self_copy.get_order();\n        n %= order;\n\n        for _ in 1..n {\n            self_copy.compose_with(self).unwrap();\n        }\n\n        self_copy\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.raw.len()\n    }\n\n    /// Computes the order of the permutation. This is the same as the size\n    /// of the subgroup generated by this permutation.\n    /// The order is the least common multiple of all cycle lengths as each\n    /// cycle has a period of its own length.\n    #[cfg(test)]\n    pub fn get_order(\u0026mut self) -\u003e usize {\n        if self.cycles.is_none() {\n            self.compute_cycles();\n        }\n\n        match \u0026self.cycles {\n            Some(cycles) =\u003e {\n                let mut size = 1;\n\n                for cycle in cycles.iter() {\n                    size = size.lcm(\u0026cycle.len());\n                }\n\n                size\n            }\n            None =\u003e unreachable!(),\n        }\n    }\n\n    /// Evaluate the permutation for a single value.\n    pub fn evaluate(\u0026self, in_value: \u0026VertexIndex) -\u003e Option\u003cVertexIndex\u003e {\n        self.get(*in_value as usize).copied()\n    }\n\n    /// Apply the permutation to the given iterator.\n    pub fn _apply\u003cI\u003e(self, iterator: I) -\u003e impl Iterator\u003cItem = VertexIndex\u003e\n    where\n        I: Iterator\u003cItem = VertexIndex\u003e,\n    {\n        iterator.map(move |value| self.evaluate(\u0026value).unwrap_or(value))\n    }\n\n    pub fn get_cycles(\u0026mut self) -\u003e Vec\u003cVec\u003cVertexIndex\u003e\u003e {\n        if self.cycles.is_none() {\n            self.compute_cycles();\n        }\n\n        self.cycles.clone().unwrap()\n    }\n\n    fn get(\u0026self, index: usize) -\u003e Option\u003c\u0026VertexIndex\u003e {\n        self.raw.get(index)\n    }\n\n    fn from_cycle(cycle: \u0026[VertexIndex], raw: \u0026mut [VertexIndex]) {\n        let first = cycle.first().unwrap();\n        let mut last = first;\n\n        for current in cycle[1..].iter() {\n            *raw.get_mut(*last as usize).unwrap() = *current;\n            last = current;\n        }\n        *raw.get_mut(*last as usize).unwrap() = *first;\n    }\n\n    fn normalize_cycle(cycle: \u0026mut [VertexIndex]) {\n        let min_index = cycle.iter().position_min_by_key(|\u0026x| *x as usize).unwrap();\n        cycle.rotate_left(min_index);\n    }\n\n    fn get_cycle(\u0026self, from: VertexIndex) -\u003e Vec\u003cVertexIndex\u003e {\n        let mut cycle = vec![from];\n\n        let mut value = self.get(from as usize).unwrap();\n\n        loop {\n            if value != \u0026from {\n                cycle.push(*value);\n                value = self.get(*value as usize).unwrap();\n            } else {\n                break;\n            }\n        }\n\n        Self::normalize_cycle(\u0026mut cycle);\n        cycle\n    }\n\n    fn compute_cycles(\u0026mut self) {\n        let mut cycles = Vec::new();\n\n        for (index, value) in self.raw.iter().enumerate() {\n            if index != *value as usize\n                \u0026\u0026 !cycles\n                    .iter()\n                    .any(|cycle: \u0026Vec\u003cVertexIndex\u003e| cycle.contains(value))\n            {\n                cycles.push(self.get_cycle(*value));\n            }\n        }\n\n        self.cycles = Some(cycles);\n    }\n\n    pub fn is_identity(\u0026self) -\u003e bool {\n        self.raw\n            .iter()\n            .enumerate()\n            .all(|(index, value)| index == *value as usize)\n    }\n}\n\nimpl\u003cT\u003e From\u003cVec\u003cT\u003e\u003e for Permutation\nwhere\n    T: TryInto\u003cVertexIndex\u003e,\n    \u003cT as TryInto\u003cVertexIndex\u003e\u003e::Error: std::fmt::Debug,\n{\n    fn from(raw: Vec\u003cT\u003e) -\u003e Self {\n        Permutation::new(raw.into_iter().map(|t| t.try_into()).try_collect().unwrap())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn compose_test() {\n        let perm1 = vec![1usize, 2, 0].into();\n        let perm2 = vec![2, 1, 0].into();\n        let comp = Permutation::compose(\u0026perm1, \u0026perm2).unwrap();\n        assert_eq!(Permutation::from(vec![0usize, 2, 1]), comp);\n\n        let perm3 = vec![0, 1, 2, 3].into();\n        let comp_error = Permutation::compose(\u0026perm1, \u0026perm3);\n        assert!(comp_error.is_err());\n    }\n\n    #[test]\n    fn compose_with_test() {\n        let perm1 = vec![1usize, 2, 0].into();\n        let mut perm2: Permutation = vec![2, 1, 0].into();\n        assert!(perm2.compose_with(\u0026perm1).is_ok());\n        assert_eq!(Permutation::from(vec![0usize, 2, 1]), perm2);\n\n        let perm3 = vec![0, 1, 2, 3].into();\n        let comp_error = perm2.compose_with(\u0026perm3);\n        assert!(comp_error.is_err());\n    }\n\n    #[test]\n    fn normalize_cycle_test() {\n        let mut cycle = vec![3, 5, 4, 2];\n        let normalized = vec![2, 3, 5, 4];\n        Permutation::normalize_cycle(\u0026mut cycle);\n        assert_eq!(normalized, cycle);\n    }\n\n    #[test]\n    fn compute_cycles_test() {\n        let raw = vec![0, 1, 3, 2];\n        let mut perm = Permutation::new(raw.clone());\n        perm.compute_cycles();\n        assert_eq!(raw, perm.raw);\n        assert_eq!(vec![vec![2, 3]], perm.cycles.unwrap());\n    }\n\n    #[test]\n    fn get_subgroup_size() {\n        let mut perm = Permutation::new_with_cycles(vec![4, 0, 1, 5, 7, 3, 2, 6]); //(0 4 7 6 2 1) (3 5)\n        let subgroup_size = perm.get_order();\n        assert_eq!(6, subgroup_size);\n\n        let mut perm2 = Permutation::new(vec![1, 2, 0, 4, 3]); // (0 1 2) (3 4)\n        let subgroup_size2 = perm2.get_order();\n        assert_eq!(6, subgroup_size2);\n\n        let mut perm3 = Permutation::new(vec![1, 2, 0, 4, 3, 8, 5, 6, 7]); // (0 1 2) (3 4) (5 8 7 6)\n        let subgroup_size3 = perm3.get_order();\n        assert_eq!(12, subgroup_size3);\n    }\n\n    #[test]\n    fn evaluate_test() {\n        let perm = Permutation::new(vec![0, 2, 1]);\n        assert_eq!(0, perm.evaluate(\u00260).unwrap());\n        assert_eq!(2, perm.evaluate(\u00261).unwrap());\n        assert_eq!(1, perm.evaluate(\u00262).unwrap());\n        assert!(perm.evaluate(\u00263).is_none());\n    }\n\n    #[test]\n    fn apply_test() {\n        let perm = Permutation::new(vec![4, 2, 1, 0, 3]);\n        let data = vec![0, 2, 3, 4, 5, 1];\n        let permuted_data: Vec\u003ci32\u003e = perm._apply(data.into_iter()).collect();\n        assert_eq!(vec![4, 1, 0, 3, 5, 2], permuted_data);\n    }\n\n    #[test]\n    fn from_cycles_test() {\n        let cycles = vec![vec![1, 2, 3], vec![0], vec![5, 6], vec![4]];\n        let perm = Permutation::from_cycles(cycles, 7);\n        let expected_perm = Permutation::new_with_cycles(vec![0, 2, 3, 1, 4, 6, 5]);\n        assert_eq!(expected_perm, perm);\n    }\n\n    #[test]\n    fn test_nth_power() {\n        let mut base = Permutation::new(vec![2, 7, 3, 4, 5, 6, 0, 1]);\n        let expected_double = Permutation::new(vec![3, 1, 4, 5, 6, 0, 2, 7]);\n\n        base.nth_power(2);\n        assert_eq!(expected_double, base);\n\n        let expected_quadrupel = Permutation::new(vec![5, 1, 6, 0, 2, 3, 4, 7]);\n        base.nth_power(2);\n        assert_eq!(expected_quadrupel, base);\n    }\n\n    #[test]\n    fn test_nth_power_of() {\n        let base = Permutation::new(vec![2, 7, 3, 4, 5, 6, 0, 1]);\n\n        let once = base.nth_power_of(1);\n        assert_eq!(base, once);\n\n        let expected_double = Permutation::new(vec![3, 1, 4, 5, 6, 0, 2, 7]);\n        assert_eq!(expected_double, base.nth_power_of(2));\n\n        let expected_tripple = Permutation::new(vec![4, 7, 5, 6, 0, 2, 3, 1]);\n        assert_eq!(expected_tripple, base.nth_power_of(3));\n\n        let expected_quadrupel = Permutation::new(vec![5, 1, 6, 0, 2, 3, 4, 7]);\n        assert_eq!(expected_quadrupel, base.nth_power_of(4));\n\n        let expected_quintuple = Permutation::new(vec![6, 7, 0, 2, 3, 4, 5, 1]);\n        assert_eq!(expected_quintuple, base.nth_power_of(5));\n\n        let expected_ident = Permutation::from_cycles(vec![], 8);\n        assert_eq!(expected_ident, base.nth_power_of(6));\n\n        assert_eq!(base, base.nth_power_of(7));\n        assert_eq!(base, base.nth_power_of_mod(7));\n    }\n}\n","traces":[{"line":19,"address":[1385808],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":20,"address":[1385822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1385840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1385920,1386054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[1385943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1385990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1386029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1386080,1386865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1386116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1386513,1386227,1386295],"length":1,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[1386529,1386817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[907104,907129],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":54,"address":[1386663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1386912,1387357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1386963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1387036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1387202,1387318,1386947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[1387265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[1387392,1387513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1387420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1387536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1387560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1387637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1387598,1387700,1387789,1387647],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[1387714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1387722,1387780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1387785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1387688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[1388241,1387808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1387852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1387862,1387986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1388236,1388096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[1388272,1388724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1388320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1388454,1388330],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1388719,1388579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1388541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1388752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[1388770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1388835,1388785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1388820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1389406,1388864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[1388909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1388993,1388919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[1389001,1389094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1389136,1389032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1389261,1389401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1389223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1389440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1389445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1389456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1389470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1389538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1389488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1389578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1389583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1389721,1389592,1389680],"length":1,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[1389690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1389670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[1389728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1389742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[907152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[907170,907229,907216],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}\u003calloc::vec::into_iter::IntoIter\u003ci32, alloc::alloc::Global\u003e\u003e"},{"line":182,"address":[1389776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1389806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1389922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1389823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1389936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[1389954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1389984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1390112,1390031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1390120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1390481,1390369,1390125,1390181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[1390474,1390386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[1390476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1390349,1390265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1390496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[907264,907274],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":207,"address":[1390595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1390608,1391164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1390642,1390738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1390716,1390880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[1391159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1390893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1390960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1391048,1391151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1390943,1390992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[1391009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1391992,1391200,1391967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1391220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[1391251,1391323,1391598],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[1391630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1391871,1391785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[907296,907328],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":237,"address":[1391917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1391660,1391521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1392016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[1392025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[907376,907391],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":257,"address":[907552,907424],"length":1,"stats":{"Line":3},"fn_name":"from\u003ci32\u003e"},{"line":258,"address":[907754,907817,907792,907840,907864,907568,907441,907516],"length":1,"stats":{"Line":12},"fn_name":"{closure#0}\u003cusize\u003e"}],"covered":89,"coverable":101},{"path":["/","__w","dqg","dqg","src","quotient.rs"],"content":"//! Functionalities to build quotient graphs from\n//! a set of generators and manage the orbits.\n\nuse custom_debug_derive::Debug;\nuse itertools::{Either, Itertools, MinMaxResult};\nuse libffi::high::{ClosureMut2, ClosureMut3, ClosureMut6};\nuse nauty_Traces_sys::{\n    allgroup, densenauty, groupautomproc, grouplevelproc, groupptr, makecosetreps, optionblk,\n    orbjoin, sparsenauty, statsblk, Traces, TracesStats, FALSE, TRUE,\n};\nuse std::{os::raw::c_int, slice::from_raw_parts, usize};\n\nuse crate::{\n    debug::print_generator,\n    do_if_some,\n    encoding::QuotientGraphEncoding,\n    graph::{Graph, NautyGraph, SparseNautyGraph, TracesGraph, Vertex, VertexIndex, DEFAULT_COLOR},\n    permutation::Permutation,\n    Error, NautyTraces, Settings,\n};\n\npub type Orbits = Vec\u003cVertexIndex\u003e;\n\n/// Call nauty with the given graph representation\n/// and compute the generators of the automorphism group\n/// for the graph. Return the generators.\npub fn compute_generators_with_nauty(\n    nauty_graph: Either\u003cNautyGraph, SparseNautyGraph\u003e,\n    settings: \u0026mut Settings,\n) -\u003e Vec\u003cPermutation\u003e {\n    let mut generators = Vec::new();\n    let (n, m);\n    let mut options;\n\n    match nauty_graph {\n        Either::Left(ref dense_nauty_graph) =\u003e {\n            let nm = dense_nauty_graph.graph_repr_sizes();\n            n = nm.0;\n            m = nm.1;\n            options = optionblk::default();\n        }\n        Either::Right(ref sparse_nauty_graph) =\u003e {\n            n = sparse_nauty_graph.partition.len();\n            m = 0;\n            options = optionblk::default_sparse();\n        }\n    }\n\n    options.schreier = TRUE;\n\n    if settings.colored_graph {\n        options.defaultptn = FALSE;\n    }\n\n    let mut stats = statsblk::default();\n    let mut orbits = vec![0_i32; n];\n\n    // Limit how long the closure can reference generators so that we can return it afterwards.\n    {\n        // Callback that copies the current generator.\n        let mut userautomproc =\n            |_count, generator_ptr: *mut c_int, _orbits, _numorbits, _stabvertex, n: c_int| {\n                let mut generator = Vec::with_capacity(n as usize);\n                let generator_raw = unsafe { from_raw_parts(generator_ptr, n as usize) };\n\n                for vertex in generator_raw {\n                    generator.push(*vertex);\n                }\n\n                generators.push(Permutation::new(generator));\n            };\n        let userautomproc = ClosureMut6::new(\u0026mut userautomproc);\n\n        options.userautomproc = Some(*userautomproc.code_ptr());\n\n        // Safety: Call to nauty library function that computes\n        // the automorphism group generator through useratomproc.\n        match nauty_graph {\n            Either::Left(mut dense_nauty_graph) =\u003e unsafe {\n                densenauty(\n                    dense_nauty_graph.adjacency_matrix.as_mut_ptr(),\n                    dense_nauty_graph.vertex_order.as_mut_ptr(),\n                    dense_nauty_graph.partition.as_mut_ptr(),\n                    orbits.as_mut_ptr(),\n                    \u0026mut options,\n                    \u0026mut stats,\n                    m as c_int,\n                    n as c_int,\n                    std::ptr::null_mut(),\n                );\n            },\n            Either::Right(mut sparse_nauty_graph) =\u003e unsafe {\n                sparsenauty(\n                    \u0026mut (\u0026mut sparse_nauty_graph.sparse_graph).into(),\n                    sparse_nauty_graph.vertex_order.as_mut_ptr(),\n                    sparse_nauty_graph.partition.as_mut_ptr(),\n                    orbits.as_mut_ptr(),\n                    \u0026mut options,\n                    \u0026mut stats,\n                    std::ptr::null_mut(),\n                );\n            },\n        }\n    }\n\n    do_if_some(settings.get_stats(), |statsistics| {\n        statsistics.log_group_size(stats.grpsize1, stats.grpsize2)\n    });\n\n    generators\n}\n\n/// Call Traces with the given graph representation\n/// and compute the generators of the automorphism group\n/// for the graph. Return the generators.\npub fn compute_generators_with_traces(\n    mut traces_graph: TracesGraph,\n    settings: \u0026mut Settings,\n) -\u003e Vec\u003cPermutation\u003e {\n    let n = traces_graph.vertex_order.len();\n    let mut generators = Vec::new();\n\n    // Limit how long the closure can reference generators so that we can return it afterwards.\n    {\n        // Callback that copies the current generator.\n        let mut userautomproc = |_count, generator_ptr: *mut c_int, n: c_int| {\n            let mut generator = Vec::with_capacity(n as usize);\n            let generator_raw = unsafe { from_raw_parts(generator_ptr, n as usize) };\n\n            for vertex in generator_raw {\n                generator.push(*vertex);\n            }\n\n            generators.push(Permutation::new(generator));\n        };\n        let userautomproc = ClosureMut3::new(\u0026mut userautomproc);\n\n        let mut options = nauty_Traces_sys::TracesOptions {\n            userautomproc: Some(*userautomproc.code_ptr()),\n            ..Default::default()\n        };\n        if settings.colored_graph {\n            options.defaultptn = FALSE;\n        }\n\n        let mut stats = TracesStats::default();\n        let mut orbits = vec![0_i32; n];\n\n        // Safety: Call to Traces library function that computes\n        // the automorphism group generators through useratomproc.\n        unsafe {\n            Traces(\n                \u0026mut (\u0026mut traces_graph.sparse_graph).into(),\n                traces_graph.vertex_order.as_mut_ptr(),\n                traces_graph.partition.as_mut_ptr(),\n                orbits.as_mut_ptr(),\n                \u0026mut options,\n                \u0026mut stats,\n                std::ptr::null_mut(),\n            );\n        }\n\n        do_if_some(settings.get_stats(), |statsistics| {\n            statsistics.log_group_size(stats.grpsize1, stats.grpsize2)\n        });\n    }\n\n    generators\n}\n\npub fn compute_generators(graph: \u0026mut Graph, settings: \u0026mut Settings) -\u003e Vec\u003cPermutation\u003e {\n    match settings.nauyt_or_traces {\n        NautyTraces::Nauty =\u003e {\n            let nauty_graph = NautyGraph::from_graph(graph);\n\n            debug_assert!(nauty_graph.check_valid());\n            compute_generators_with_nauty(Either::Left(nauty_graph), settings)\n        }\n        NautyTraces::SparseNauty =\u003e {\n            let sparse_nauty_graph = SparseNautyGraph::from_graph(graph);\n            compute_generators_with_nauty(Either::Right(sparse_nauty_graph), settings)\n        }\n        NautyTraces::Traces =\u003e {\n            let traces_graph = TracesGraph::from_graph(graph);\n            compute_generators_with_traces(traces_graph, settings)\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn search_group(graph: \u0026mut Graph, mut nauty_graph: NautyGraph, settings: \u0026mut Settings) {\n    let generators = compute_generators_with_nauty(Either::Left(nauty_graph.clone()), settings);\n\n    for generator in generators {\n        print!(\"Generator: \");\n        print_generator(generator);\n    }\n\n    // First, call nauty to compute the group.\n    let (n, m) = nauty_graph.graph_repr_sizes();\n    let mut options = optionblk::default();\n\n    if settings.colored_graph {\n        options.defaultptn = FALSE;\n    }\n\n    let mut stats = statsblk::default();\n    let mut orbits = vec![0_i32; n];\n\n    // Set custom group generating methods.\n    options.userautomproc = Some(groupautomproc);\n    options.userlevelproc = Some(grouplevelproc);\n\n    unsafe {\n        densenauty(\n            nauty_graph.adjacency_matrix.as_mut_ptr(),\n            nauty_graph.vertex_order.as_mut_ptr(),\n            nauty_graph.partition.as_mut_ptr(),\n            orbits.as_mut_ptr(),\n            \u0026mut options,\n            \u0026mut stats,\n            m as c_int,\n            n as c_int,\n            std::ptr::null_mut(),\n        );\n    }\n\n    // Don't forget to sort. Otherwise, the encoding will be wrong.\n    graph.sort();\n\n    // Then search in the group.\n    let mut handle_automorphism = |autom_ptr: *mut c_int, n: c_int| {\n        let mut automorphism = Vec::with_capacity(n as usize);\n        let automorphism_raw = unsafe { from_raw_parts(autom_ptr, n as usize) };\n\n        for vertex in automorphism_raw {\n            automorphism.push(*vertex);\n        }\n\n        let quotient = QuotientGraph::from_automorphism(graph, \u0026mut automorphism);\n        let formula = crate::encoding::encode_problem(\u0026quotient, graph);\n\n        if let Some((formula, _)) = formula {\n            let descriptive = crate::sat_solving::solve(formula);\n\n            if let Ok(true) = descriptive {\n                print!(\"Descriptive induced by \");\n                print_generator(Permutation::new_with_cycles(automorphism));\n            } else {\n                print!(\"Nondescriptive induced by \");\n                print_generator(Permutation::new_with_cycles(automorphism));\n            }\n        } else {\n            print!(\"Automorphism induced trivially descriptive: \");\n            print_generator(Permutation::new_with_cycles(automorphism));\n        }\n    };\n    let handle_automorphism = ClosureMut2::new(\u0026mut handle_automorphism);\n\n    unsafe {\n        let group = groupptr(TRUE);\n        if group.is_null() {\n            panic!(\"The group ptr is null!\");\n        }\n        makecosetreps(group);\n        allgroup(group, Some(*handle_automorphism.code_ptr()));\n    }\n}\n\n// Apply a generator to the current orbits and combine those,\n// the the generator connects. Does not change the generator\n// (the \u0026mut is for FFI reasons only, will not write into it).\nfn apply_generator(generator: \u0026mut [VertexIndex], orbits: \u0026mut Orbits) {\n    debug_assert_eq!(generator.len(), orbits.len());\n\n    // Safety: Call to nauty library function that reads from the generator\n    // and combines orbits accordingly. There probably is no nicer way to do this.\n    unsafe {\n        orbjoin(\n            orbits.as_mut_ptr(),\n            generator.as_mut_ptr(),\n            generator.len() as c_int,\n        );\n    }\n}\n\npub fn empty_orbits(number_vertices: usize) -\u003e Orbits {\n    let mut orbits = Vec::with_capacity(number_vertices);\n\n    for vertex in 0..number_vertices {\n        orbits.push(vertex as VertexIndex);\n    }\n\n    orbits\n}\n\nfn get_orbit(orbits: \u0026[VertexIndex], vertex: VertexIndex) -\u003e VertexIndex {\n    *orbits\n        .get(vertex as usize)\n        .expect(\"Vertex not part of given orbits!\")\n}\n\n// Generate the orbits of a quotient graph from the generators of the original graph.\npub fn generate_orbits(generators: \u0026mut [Permutation]) -\u003e Orbits {\n    let number_of_vertices = generators\n        .first()\n        .expect(\"Empty subset can't be used to generate orbits\")\n        .len();\n    let mut orbits = empty_orbits(number_of_vertices);\n\n    for generator in generators {\n        apply_generator(\u0026mut generator.raw, \u0026mut orbits);\n    }\n\n    orbits\n}\n\n/// Represents a quotient graph where the vertices are\n/// orbits. It also holds the reference to which original\n/// vertices are part of which orbit.\n#[derive(Debug)]\npub struct QuotientGraph {\n    pub quotient_graph: Graph,\n    #[debug(skip)]\n    pub orbits: Orbits,\n}\n\nimpl QuotientGraph {\n    #[cfg(not(tarpaulin_include))]\n    fn from_automorphism(graph: \u0026Graph, automorphism: \u0026mut [VertexIndex]) -\u003e Self {\n        let mut orbits = empty_orbits(graph.size());\n        apply_generator(automorphism, \u0026mut orbits);\n        Self::from_graph_orbits(graph, orbits)\n    }\n\n    /// Generates the quotient graph where each orbit is represented\n    /// by the vertex with the smallest index in the orbit.\n    pub fn from_graph_orbits(graph: \u0026Graph, orbits: Orbits) -\u003e Self {\n        let unique_orbits = orbits\n            .iter()\n            .unique()\n            .copied()\n            .collect::\u003cVec\u003cVertexIndex\u003e\u003e();\n\n        let mut quotient_graph;\n\n        // We don't need to search for edges if there can't be any.\n        if unique_orbits.len() \u003e 1 {\n            quotient_graph = Graph::new_with_indices(\u0026unique_orbits, true);\n            // Add edges between the orbits if single vertices in these are\n            // connected by an edge. Doesn't add edges within the same orbit.\n            graph.iterate_edges().for_each(|(start, end)| {\n                let start_orbit = get_orbit(\u0026orbits, start);\n                let end_orbit = get_orbit(\u0026orbits, end);\n                if start_orbit != end_orbit {\n                    quotient_graph\n                        .add_arc(start_orbit, end_orbit)\n                        .expect(\"Orbits not found in quotient graph!\");\n                }\n            });\n\n            // Edges between orbits might be generated more often than once.\n            quotient_graph.minimize();\n        } else {\n            quotient_graph = Graph::new_ordered(1);\n            quotient_graph\n                .set_vertex(Vertex::new(0, DEFAULT_COLOR))\n                .expect(\"Single vertex could not be added!\");\n        }\n\n        QuotientGraph {\n            quotient_graph,\n            orbits,\n        }\n    }\n\n    pub fn get_orbit_sizes(\u0026self) -\u003e (usize, usize) {\n        let mut counter = vec![0usize; self.orbits.len()];\n        self.orbits\n            .iter()\n            .for_each(|orbit| counter[*orbit as usize] += 1);\n        match counter.iter().filter(|size| **size \u003e 0).minmax() {\n            MinMaxResult::NoElements =\u003e (0, 0),\n            MinMaxResult::OneElement(m) =\u003e (*m, *m),\n            MinMaxResult::MinMax(min, max) =\u003e (*min, *max),\n        }\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn search_non_descriptive_core(self, graph: \u0026Graph) -\u003e Option\u003cQuotientGraphEncoding\u003e {\n        use crate::encoding::{\n            EdgeEncoding, HighLevelEncoding, SATEncoding, SATEncodingDictionary,\n        };\n        use rayon::prelude::*;\n        let QuotientGraphEncoding(quotient_edges, orbits) = self.encode_high();\n\n        orbits\n            .iter()\n            .cloned()\n            .combinations(4) // From observations it seemed that such cores are mostly of size 4.\n            .par_bridge()\n            .find_map_any(|orbit_subset| {\n                let mut dict = SATEncodingDictionary::default();\n                let edge_subset = quotient_edges\n                    .iter()\n                    .filter(|edge| {\n                        let (start, end) = edge.get_edge();\n                        orbit_subset.iter().any(|(orbit, _)| *orbit == start)\n                            \u0026\u0026 orbit_subset.iter().any(|(orbit, _)| *orbit == end)\n                    })\n                    .copied()\n                    .collect::\u003cVec\u003cEdgeEncoding\u003e\u003e();\n\n                let descriptive_constraint_encoding =\n                    QuotientGraphEncoding(edge_subset.clone(), orbit_subset.clone())\n                        .encode_sat(\u0026mut dict, graph);\n\n                let transversal_encoding = orbit_subset\n                    .iter()\n                    .flat_map(|orbit| orbit.encode_sat(\u0026mut dict, graph));\n\n                if !crate::solve(\n                    transversal_encoding.chain(descriptive_constraint_encoding.into_iter()),\n                )\n                .unwrap()\n                {\n                    Some(QuotientGraphEncoding(edge_subset, orbit_subset))\n                } else {\n                    None\n                }\n            })\n    }\n\n    pub fn induced_subquotient(\u0026self, orbit_subset: \u0026[VertexIndex]) -\u003e Result\u003cSelf, Error\u003e {\n        let mut sub_orbits = self.orbits.clone();\n        sub_orbits.iter_mut().for_each(|orbit| {\n            if orbit_subset.binary_search(orbit).is_err() {\n                *orbit = -1;\n            }\n        });\n\n        Ok(QuotientGraph {\n            quotient_graph: self.quotient_graph.induce_subgraph(orbit_subset, true)?,\n            orbits: sub_orbits,\n        })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::{graph::GraphError, Error};\n\n    #[test]\n    fn test_from_graph_orbits() -\u003e Result\u003c(), Error\u003e {\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(1, 5)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 7)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(4, 7)?;\n        graph.add_edge(5, 6)?;\n        graph.add_edge(6, 7)?;\n\n        let orbits = vec![0, 1, 2, 1, 4, 0, 1, 0];\n\n        let quotient = QuotientGraph::from_graph_orbits(\u0026graph, orbits.clone());\n        assert_eq!(orbits, quotient.orbits);\n\n        let mut expected_vert0 = Vertex::new(0, DEFAULT_COLOR);\n        expected_vert0.add_edge(1);\n        expected_vert0.add_edge(4);\n        let mut expected_vert1 = Vertex::new(1, DEFAULT_COLOR);\n        expected_vert1.add_edge(0);\n        expected_vert1.add_edge(2);\n        let mut expected_vert2 = Vertex::new(2, DEFAULT_COLOR);\n        expected_vert2.add_edge(1);\n        let mut expected_vert4 = Vertex::new(4, DEFAULT_COLOR);\n        expected_vert4.add_edge(0);\n\n        assert_eq!(4, quotient.quotient_graph.size());\n        assert_eq!(expected_vert0, *quotient.quotient_graph.get_vertex(0)?);\n        assert_eq!(expected_vert1, *quotient.quotient_graph.get_vertex(1)?);\n        assert_eq!(expected_vert2, *quotient.quotient_graph.get_vertex(2)?);\n        assert_eq!(expected_vert4, *quotient.quotient_graph.get_vertex(4)?);\n\n        // Single orbit\n        let graph = Graph::new_ordered(1);\n        let orbits = vec![0];\n\n        let quotient = QuotientGraph::from_graph_orbits(\u0026graph, orbits.clone());\n        assert_eq!(orbits, quotient.orbits);\n        assert_eq!(\n            Vertex::new(0, DEFAULT_COLOR),\n            *quotient.quotient_graph.get_vertex(0)?\n        );\n        assert_eq!(1, quotient.quotient_graph.size());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_apply_generator() {\n        let mut orbits = empty_orbits(7);\n        let mut generator = [0, 1, 4, 3, 2, 6, 5];\n\n        apply_generator(\u0026mut generator, \u0026mut orbits);\n\n        assert_eq!(orbits, [0, 1, 2, 3, 2, 5, 5]);\n    }\n\n    #[test]\n    fn test_generate_orbits() {\n        let mut generators = vec![\n            vec![5, 1, 2, 6, 4, 0, 3, 7].into(),\n            vec![0, 3, 2, 1, 4, 7, 6, 5].into(),\n        ];\n        let orbits = generate_orbits(\u0026mut generators);\n        assert_eq!(orbits, vec![0, 1, 2, 1, 4, 0, 1, 0]);\n    }\n\n    #[test]\n    fn test_compute_generators_with_dense_nauty() -\u003e Result\u003c(), GraphError\u003e {\n        let mut settings = Settings {\n            colored_graph: true,\n            ..Default::default()\n        };\n\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(1, 5)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 7)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(4, 7)?;\n        graph.add_edge(5, 6)?;\n        graph.add_edge(6, 7)?;\n\n        let order = [2, 0, 1, 3, 4, 5, 6, 7];\n        let colours = [2, 2, 1, 2, 2, 2, 2, 2];\n        graph.set_colours(\u0026colours)?;\n        graph.order(\u0026order)?;\n\n        // Test dense nauty\n        let nauty_graph = NautyGraph::from_graph(\u0026mut graph);\n        assert!(nauty_graph.check_valid());\n        let expected_generators: Vec\u003cPermutation\u003e = vec![\n            vec![5, 1, 2, 6, 4, 0, 3, 7].into(),\n            vec![0, 3, 2, 1, 4, 7, 6, 5].into(),\n        ];\n        let generators = compute_generators_with_nauty(Either::Left(nauty_graph), \u0026mut settings);\n        assert_eq!(expected_generators, generators);\n\n        // Test sparse nauty\n        let sparse_nauty_graph = SparseNautyGraph::from_graph(\u0026mut graph);\n        let expected_generators: Vec\u003cPermutation\u003e = vec![\n            vec![0, 3, 2, 1, 4, 7, 6, 5].into(),\n            vec![5, 1, 2, 6, 4, 0, 3, 7].into(),\n        ];\n        let generators =\n            compute_generators_with_nauty(Either::Right(sparse_nauty_graph), \u0026mut settings);\n        assert_eq!(expected_generators, generators);\n\n        // Test traces\n        let traces_graph = TracesGraph::from_graph(\u0026mut graph);\n        let expected_generators: Vec\u003cPermutation\u003e = vec![\n            vec![7, 3, 2, 6, 4, 0, 1, 5].into(),\n            vec![5, 1, 2, 6, 4, 0, 3, 7].into(),\n        ];\n        let generators = compute_generators_with_traces(traces_graph, \u0026mut settings);\n\n        assert_eq!(expected_generators, generators);\n\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[1268175,1268618,1266816],"length":1,"stats":{"Line":1},"fn_name":"compute_generators_with_nauty"},{"line":31,"address":[1266863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1266995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1267003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[1267041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1267172,1267053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[1267188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1267196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1267204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1267084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1267092,1267284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1267292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1267304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1267257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1267381,1267268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1267370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1267351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1267383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[931248,931679,931708],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":63,"address":[931319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[931431,931363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[931611,931447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[931674,931624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[931546,931651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[1267444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1267503,1267565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[1267592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1267706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1267905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1267929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1267953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1267977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1267989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1267832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[1268224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1268248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1268272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[931728],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":107,"address":[931753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1268504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[1268672,1269627],"length":1,"stats":{"Line":1},"fn_name":"compute_generators_with_traces"},{"line":120,"address":[1268777,1268715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1268790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[931792,932199,932228],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":127,"address":[931839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[931883,931951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[932131,931967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[932144,932194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[932066,932171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[1268820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1268923,1268869],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[1269148,1269187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[1269176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1269157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[1269194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1269220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1269291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1269316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1269336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[932240],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":164,"address":[932265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1269583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1270207,1269664,1270232],"length":1,"stats":{"Line":0},"fn_name":"compute_generators"},{"line":172,"address":[1269707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1269756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1269774,1269899,1269955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1270004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1269781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1269794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1269853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1269876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1271808],"length":1,"stats":{"Line":1},"fn_name":"apply_generator"},{"line":274,"address":[1271864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[1271997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[1272032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[1272048,1272335],"length":1,"stats":{"Line":1},"fn_name":"empty_orbits"},{"line":288,"address":[1272083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1272189,1272093,1272300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[1272316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[1272266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[1272368],"length":1,"stats":{"Line":1},"fn_name":"get_orbit"},{"line":298,"address":[1272388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1272385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1272789,1272432],"length":1,"stats":{"Line":1},"fn_name":"generate_orbits"},{"line":305,"address":[1272488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[1272544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1272627,1272734,1272559],"length":1,"stats":{"Line":3},"fn_name":null},{"line":312,"address":[1272747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[1272700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[1273072,1273979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1273115,1273211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[1273363,1273296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[1273389,1273769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[933728,933758],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":353,"address":[933766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[933803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[933841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[933863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[1273920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[1273418,1273382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[1273512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[1273489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[1274032,1274496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[1274047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1274163,1274203,1274091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[933918,933904],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":382,"address":[934026,934016],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":383,"address":[1274362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[1274382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[1274416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[1275008,1275546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[1275048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[936064],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":437,"address":[936085,936140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[936134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[1275356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1275454,1275198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[1275317],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":91,"coverable":118},{"path":["/","__w","dqg","dqg","src","sat_solving.rs"],"content":"use std::{\n    collections::HashMap,\n    convert::TryInto,\n    fs::File,\n    process::{Command, Stdio},\n    sync::Arc,\n};\n\nuse flussab_cnf::cnf::Parser;\nuse itertools::Itertools;\nuse kissat_rs::{Assignment, Solver};\nuse num::ToPrimitive;\n\nuse crate::{\n    debug::write_formula_dimacs,\n    encoding::{\n        encode_problem, Clause, HighLevelEncoding, QuotientGraphEncoding, SATEncodingDictionary,\n    },\n    graph::{Graph, VertexIndex},\n    parser::_parse_mus,\n    quotient::QuotientGraph,\n    Error,\n};\n\npub fn solve(formula: impl Iterator\u003cItem = Clause\u003e) -\u003e Result\u003cbool, Error\u003e {\n    Solver::decide_formula(formula).map_err(Error::from)\n}\n\nfn get_transversal(\n    assignment: HashMap\u003ci32, Option\u003cAssignment\u003e\u003e,\n    dict: SATEncodingDictionary,\n) -\u003e Vec\u003c(VertexIndex, VertexIndex)\u003e {\n    let mut picked = dict\n        .destroy()\n        .into_iter()\n        .enumerate()\n        .filter(|(literal, _)| {\n            matches!(\n                assignment.get(\u0026(literal.to_i32().unwrap())),\n                Some(Some(Assignment::True))\n            )\n        })\n        .map(|(_, orbit_vertex)| orbit_vertex)\n        .collect_vec();\n    picked.sort_unstable_by(|(orbit1, _), (orbit2, _)| orbit1.cmp(orbit2));\n    picked\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn solve_validate(\n    formula: impl Iterator\u003cItem = Clause\u003e,\n    dict: SATEncodingDictionary,\n) -\u003e Result\u003cOption\u003cVec\u003c(VertexIndex, VertexIndex)\u003e\u003e, Error\u003e {\n    let assignment = Solver::solve_formula(formula).map_err(Error::from)?;\n    Ok(assignment.map(|assignment| get_transversal(assignment, dict)))\n}\n\nfn _get_core_orbits_indexed(\n    clause_indices: \u0026[usize],\n    formula: \u0026[Clause],\n    dict: SATEncodingDictionary,\n) -\u003e Vec\u003cVertexIndex\u003e {\n    let core_formula = clause_indices\n        .iter()\n        .map(|index| {\n            formula\n                .get(index - 1)\n                .expect(\"Clause index out of range!\")\n                .clone()\n        })\n        .collect_vec();\n    get_core_orbits(\u0026core_formula, dict)\n}\n\nfn get_core_orbits(core_formula: \u0026[Clause], dict: SATEncodingDictionary) -\u003e Vec\u003cVertexIndex\u003e {\n    let mut core_orbits = Vec::new();\n    let raw_dict = dict.destroy();\n\n    for clause in core_formula {\n        for variable in clause {\n            let orbit = raw_dict\n                .get::\u003cusize\u003e(\n                    variable\n                        .abs()\n                        .try_into()\n                        .expect(\"Could not transform literal to usize!\"),\n                )\n                .expect(\"Variable not in dict!\")\n                .0;\n            core_orbits.push(orbit);\n        }\n    }\n\n    core_orbits.sort_unstable();\n    core_orbits.dedup();\n\n    core_orbits\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn _solve_mus(\n    formula: impl Iterator\u003cItem = Clause\u003e,\n    quotient_graph: \u0026QuotientGraph,\n    graph: \u0026Graph,\n    dict: SATEncodingDictionary,\n) -\u003e Result\u003cOption\u003cQuotientGraphEncoding\u003e, Error\u003e {\n    let formula_collected = formula.collect_vec();\n\n    if Solver::decide_formula(formula_collected.iter().cloned())? {\n        Ok(None)\n    } else {\n        let mut mus = Command::new(\"picomus\")\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()?;\n        let mut stdin = mus.stdin.take().expect(\"Failed to open stdin to picomus!\");\n\n        let variable_number = dict.variable_number();\n        let formula_arc = Arc::new(formula_collected);\n        let closure_formula_arc = formula_arc.clone();\n        std::thread::spawn(move || {\n            write_formula_dimacs(\u0026mut stdin, \u0026closure_formula_arc, variable_number)\n                .expect(\"Failed to write to stdin of picomus!\")\n        });\n        let mus_out = mus.wait_with_output()?;\n\n        // 20 for Unsatisfiable\n        if mus_out.status.code() == Some(20) {\n            let core = _parse_mus(\u0026mus_out.stdout)?;\n            let core_orbits = _get_core_orbits_indexed(\u0026core, \u0026formula_arc, dict);\n            dbg!(\u0026core_orbits);\n            let sub_quotient = quotient_graph.induced_subquotient(\u0026core_orbits)?;\n\n            // Make sure that the found orbits are in fact a non-descriptive core.\n            // I don't really doubt picmus, but who knows what kind of MUS it finds.\n            let (formula, _) = encode_problem(\u0026sub_quotient, graph).unwrap();\n            assert!(matches!(solve(formula), Ok(false)));\n\n            Ok(Some(sub_quotient.encode_high()))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn solve_mus_kitten(\n    formula: impl Iterator\u003cItem = Clause\u003e,\n    quotient_graph: \u0026QuotientGraph,\n    graph: \u0026Graph,\n    dict: SATEncodingDictionary,\n) -\u003e Result\u003cOption\u003cQuotientGraphEncoding\u003e, Error\u003e {\n    use flussab_cnf::cnf::Config;\n\n    let formula_collected = formula.collect_vec();\n\n    if Solver::decide_formula(formula_collected.iter().cloned())? {\n        Ok(None)\n    } else {\n        let mut dqg_file = File::create(\"./dqg.cnf\")?;\n        let variable_number = dict.variable_number();\n        write_formula_dimacs(\u0026mut dqg_file, \u0026formula_collected, variable_number)?;\n\n        let mut kitten = Command::new(\"./kitten\")\n            .arg(\"-O25\")\n            .arg(\"./dqg.cnf\")\n            .arg(\"./core.cnf\")\n            .stdout(Stdio::piped())\n            .spawn()?;\n        let kitten_exit = kitten.wait()?;\n\n        // 20 for Unsatisfiable\n        if kitten_exit.code() == Some(20) {\n            let core_file = File::open(\"./core.cnf\")?;\n            let conf = Config::ignore_header(Default::default(), true);\n            let mut core_parser = Parser::from_read(core_file, conf).unwrap();\n            let mut core: Vec\u003cVec\u003cVertexIndex\u003e\u003e = Vec::new();\n\n            loop {\n                let next = core_parser.next_clause().unwrap();\n                match next {\n                    Some(clause) =\u003e core.push(clause.to_vec()),\n                    None =\u003e break,\n                }\n            }\n\n            let core_orbits = get_core_orbits(\u0026core, dict);\n            let sub_quotient = quotient_graph.induced_subquotient(\u0026core_orbits)?;\n\n            // Make sure that the found orbits are in fact a non-descriptive core.\n            // I don't really doubt picmus, but who knows what kind of MUS it finds.\n            let (formula, _) = encode_problem(\u0026sub_quotient, graph).unwrap();\n            assert!(matches!(solve(formula), Ok(false)));\n\n            Ok(Some(sub_quotient.encode_high()))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::{encoding::encode_problem, graph::Graph, quotient::QuotientGraph};\n\n    use super::*;\n\n    #[test]\n    fn test_non_descriptive() -\u003e Result\u003c(), Error\u003e {\n        //0-1-2-3, where 1 and 2 are in the same (fake) orbit.\n        let mut graph = Graph::new_ordered(4);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(2, 3)?;\n        let colors = vec![1, 2, 2, 3];\n        graph.set_colours(\u0026colors)?;\n\n        // Not the actual orbits, but used to check for non-descriptiveness.\n        let fake_orbits = vec![0, 1, 1, 3];\n        let quotient = QuotientGraph::from_graph_orbits(\u0026graph, fake_orbits);\n\n        let formula = encode_problem(\u0026quotient, \u0026graph);\n\n        let result = solve(formula.unwrap().0);\n        assert!(result.is_ok());\n        assert_eq!(false, result.unwrap());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_get_transversal() {\n        // Orbit 1: {0,1}\n        // orbit 2: {2,3}\n        // Edges: 0-2,1-3\n        // Transversal: 0|-\u003e0,2|-\u003e3\n\n        let mut assignment = HashMap::new();\n        assignment.insert(1, Some(Assignment::True));\n        assignment.insert(2, Some(Assignment::False));\n        assignment.insert(3, Some(Assignment::True));\n        assignment.insert(4, Some(Assignment::False));\n\n        let mut dict = SATEncodingDictionary::default();\n        assert_eq!(1, dict.lookup_pairing(0, 0));\n        assert_eq!(2, dict.lookup_pairing(0, 1));\n        assert_eq!(3, dict.lookup_pairing(2, 3));\n        assert_eq!(4, dict.lookup_pairing(2, 2));\n\n        let expected_transversal = vec![(0, 0), (2, 3)];\n        assert_eq!(expected_transversal, get_transversal(assignment, dict));\n    }\n\n    #[test]\n    fn test_get_core_orbits_indexed() {\n        let mut dict = SATEncodingDictionary::default();\n        let pairs = vec![\n            (14, 14),\n            (14, 34),\n            (22, 22),\n            (22, 26),\n            (134, 144),\n            (134, 134),\n            (154, 154),\n            (154, 158),\n            (127, 127),\n        ];\n        for (index, (orbit, vertex)) in pairs.into_iter().enumerate() {\n            assert_eq!(index as VertexIndex + 1, dict.lookup_pairing(orbit, vertex));\n        }\n\n        let formula = vec![vec![1, 2], vec![-1, -2], vec![3, 4], vec![-3, -4], vec![9]];\n        let core = vec![1, 3, 5];\n\n        let expected_orbits = vec![14, 22, 127];\n\n        assert_eq!(\n            expected_orbits,\n            _get_core_orbits_indexed(\u0026core, \u0026formula, dict)\n        );\n    }\n}\n","traces":[{"line":25,"address":[1323424,1323472],"length":1,"stats":{"Line":1},"fn_name":"solve\u003ccore::iter::adapters::chain::Chain\u003calloc::vec::into_iter::IntoIter\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e, alloc::alloc::Global\u003e, alloc::vec::into_iter::IntoIter\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e, alloc::alloc::Global\u003e\u003e\u003e"},{"line":26,"address":[1323437,1323485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1036096,1036440],"length":1,"stats":{"Line":1},"fn_name":"get_transversal"},{"line":33,"address":[1036199,1036139,1036242],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[1323547,1323520],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":38,"address":[1323651,1323676,1323697],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[1323657,1323612,1323689,1323552],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[1323728,1323733],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":45,"address":[1323803,1323760],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":46,"address":[1036396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[1036464,1036848],"length":1,"stats":{"Line":1},"fn_name":"_get_core_orbits_indexed"},{"line":63,"address":[1036538,1036639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[1036631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1324547,1324597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1324567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1036753,1036681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[1036896,1037886,1037855],"length":1,"stats":{"Line":1},"fn_name":"get_core_orbits"},{"line":76,"address":[1036959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1037047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1037375,1037190,1037266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[1037528,1037391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[1037775,1037643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[1037685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1037843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1037358,1037418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1037433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1037448],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":27},{"path":["/","__w","dqg","dqg","src","statistics.rs"],"content":"//! Statistics about different parts of the program.\n\nuse custom_debug_derive::Debug;\nuse std::{\n    collections::HashMap,\n    fs::File,\n    io::Write,\n    path::PathBuf,\n    time::{Duration, Instant},\n};\n\nuse crate::{\n    debug::{opt_fmt, result_fmt},\n    encoding::OrbitEncoding,\n    Error,\n};\n\n#[derive(Debug, PartialEq, Eq)]\npub enum StatisticsLevel {\n    None,\n    Basic,\n    Full,\n}\n\nimpl From\u003cu64\u003e for StatisticsLevel {\n    #[cfg(not(tarpaulin_include))]\n    fn from(level: u64) -\u003e Self {\n        match level {\n            0 =\u003e Self::None,\n            1 =\u003e Self::Basic,\n            _ =\u003e Self::Full,\n        }\n    }\n}\n\n/// Counts how many orbits have the same size.\n/// Stores the as a map from orbit size to number\n/// of orbits with this size.\n#[derive(Default)]\npub struct OrbitStatistics {\n    pub orbit_sizes: HashMap\u003cusize, usize\u003e,\n}\n\nimpl OrbitStatistics {\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_orbit(\u0026mut self, orbit: \u0026OrbitEncoding) {\n        let orbit_size = orbit.1.len();\n        match self.orbit_sizes.get_mut(\u0026orbit_size) {\n            Some(number) =\u003e *number += 1,\n            None =\u003e {\n                self.orbit_sizes.insert(orbit_size, 1);\n            }\n        };\n    }\n}\n\n#[derive(Debug)]\npub struct QuotientStatistics {\n    pub quotient_size: usize,\n    #[debug(with = \"opt_fmt\")]\n    pub core_size: Option\u003cusize\u003e,\n    pub max_orbit_size: usize,\n    pub min_orbit_size: usize,\n    #[debug(with = \"result_fmt\")]\n    pub descriptive: Result\u003cbool, Error\u003e,\n    #[debug(with = \"opt_fmt\")]\n    pub validated: Option\u003cbool\u003e,\n    pub quotient_handling_time: Duration,\n    pub kissat_time: Duration,\n    pub orbit_gen_time: Duration,\n    pub quotient_gen_time: Duration,\n    pub encoding_time: Duration,\n    pub orbit_sizes: OrbitStatistics,\n}\n\n#[derive(Debug)]\npub struct Statistics {\n    // Meta information\n    #[debug(skip)]\n    level: StatisticsLevel,\n    #[debug(skip)]\n    out_file: PathBuf,\n    pub exhausted: bool,\n    // Timings\n    #[debug(skip)]\n    pub start_time: Instant,\n    #[debug(with = \"opt_fmt\")]\n    nauty_done_time: Option\u003cDuration\u003e,\n    #[debug(with = \"opt_fmt\")]\n    gap_done_time: Option\u003cDuration\u003e,\n    #[debug(with = \"opt_fmt\")]\n    end_time: Option\u003cDuration\u003e,\n    #[debug(with = \"opt_fmt\")]\n    graph_sort_time: Option\u003cDuration\u003e,\n    // Graph statistics\n    graph_size: usize,\n    group_size: f64,\n    iteration_counter: usize,\n    descriptive_found: bool,\n    #[debug(with = \"opt_fmt\")]\n    number_of_generators: Option\u003cusize\u003e,\n    max_orbit_size: usize,\n    max_quotient_graph_size: usize,\n    #[debug(with = \"opt_fmt\")]\n    max_quotient_handling_time: Option\u003cDuration\u003e,\n    #[debug(with = \"opt_fmt\")]\n    max_kissat_time: Option\u003cDuration\u003e,\n    quotient_statistics: Vec\u003cQuotientStatistics\u003e,\n}\n\nimpl Statistics {\n    #[cfg(not(tarpaulin_include))]\n    pub fn new(level: StatisticsLevel, out_file: PathBuf, graph_size: usize) -\u003e Self {\n        debug_assert!(level != StatisticsLevel::None);\n\n        Statistics {\n            level,\n            out_file,\n            start_time: Instant::now(),\n            exhausted: false,\n            nauty_done_time: None,\n            gap_done_time: None,\n            end_time: None,\n            graph_sort_time: None,\n            graph_size,\n            group_size: 0.,\n            iteration_counter: 0,\n            descriptive_found: false,\n            number_of_generators: None,\n            max_orbit_size: 0,\n            max_quotient_graph_size: 0,\n            max_quotient_handling_time: None,\n            max_kissat_time: None,\n            quotient_statistics: Vec::new(),\n        }\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_iteration(\u0026mut self) {\n        self.iteration_counter += 1;\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_group_size(\u0026mut self, base: f64, mantisse: i32) {\n        use num::traits::Pow;\n\n        self.group_size = base * 10f64.pow(mantisse);\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_nauty_done(\u0026mut self) {\n        self.nauty_done_time = Some(self.start_time.elapsed());\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_nauty_step(\u0026mut self, duration: Duration) {\n        Self::add_option_duration(\u0026mut self.nauty_done_time, duration);\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_gap_done(\u0026mut self, duration: Duration) {\n        self.gap_done_time = Some(duration);\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_graph_sorted(\u0026mut self, duration: Duration) {\n        self.graph_sort_time = Some(duration);\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_graph_sorted_step(\u0026mut self, duration: Duration) {\n        Self::add_option_duration(\u0026mut self.graph_sort_time, duration);\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_end(\u0026mut self) {\n        self.end_time = Some(self.start_time.elapsed());\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_number_of_generators(\u0026mut self, number_of_generators: usize) {\n        self.number_of_generators = Some(number_of_generators);\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn log_quotient_statistic(\u0026mut self, quotient_statistic: QuotientStatistics) {\n        self.descriptive_found |= matches!(quotient_statistic.descriptive, Ok(true));\n        self.max_orbit_size = self.max_orbit_size.max(quotient_statistic.max_orbit_size);\n        self.max_quotient_graph_size = self\n            .max_quotient_graph_size\n            .max(quotient_statistic.quotient_size);\n        self.max_quotient_handling_time = if let Some(qh_time) = self.max_quotient_handling_time {\n            Some(qh_time.max(quotient_statistic.quotient_handling_time))\n        } else {\n            Some(quotient_statistic.quotient_handling_time)\n        };\n        self.max_kissat_time = if let Some(ks_time) = self.max_kissat_time {\n            Some(ks_time.max(quotient_statistic.kissat_time))\n        } else {\n            Some(quotient_statistic.kissat_time)\n        };\n\n        if self.level == StatisticsLevel::Full {\n            self.quotient_statistics.push(quotient_statistic);\n        }\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    fn add_option_duration(old: \u0026mut Option\u003cDuration\u003e, new: Duration) {\n        match old {\n            Some(old) =\u003e *old += new,\n            None =\u003e *old = Some(new),\n        }\n    }\n\n    #[cfg(not(tarpaulin_include))]\n    pub fn save_statistics(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        let mut statistics_file = File::create(\u0026self.out_file)?;\n        write!(statistics_file, \"Raw Statistics: {:#?}\", self).map_err(Error::from)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","__w","dqg","dqg","src","transversal.rs"],"content":"use crate::{\n    encoding::QuotientGraphEncoding,\n    graph::{Graph, VertexIndex},\n};\n\npub fn is_transversal_consistent(\n    transversal: \u0026[(VertexIndex, VertexIndex)],\n    graph: \u0026Graph,\n    quotient: QuotientGraphEncoding,\n) -\u003e bool {\n    for edge in quotient.0.iter() {\n        let start = transversal[transversal\n            .binary_search_by(|(orbit, _)| orbit.cmp(\u0026edge.0))\n            .expect(\"Transversal didn't contain orbit!\")]\n        .1;\n        let end = transversal[transversal\n            .binary_search_by(|(orbit, _)| orbit.cmp(\u0026edge.1))\n            .expect(\"Transversal didn't contain orbit!\")]\n        .1;\n\n        if !graph.lookup_edge(\u0026start, \u0026end) {\n            return false;\n        }\n    }\n\n    true\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::{encoding::EdgeEncoding, Error};\n\n    #[test]\n    fn test_is_transversal_consistent_true() -\u003e Result\u003c(), Error\u003e {\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 3)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 2)?;\n        graph.add_edge(1, 5)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 7)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(4, 7)?;\n        graph.add_edge(5, 6)?;\n        graph.add_edge(6, 7)?;\n\n        let quotient1: QuotientGraphEncoding = QuotientGraphEncoding(\n            vec![EdgeEncoding(0, 2)],\n            vec![(0, vec![0, 1, 4, 5]), (2, vec![2, 3, 6, 7])],\n        );\n        let transversal1_1 = vec![(0, 0), (2, 3)];\n        assert!(is_transversal_consistent(\n            \u0026transversal1_1,\n            \u0026graph,\n            quotient1.clone()\n        ));\n        let transversal1_2 = vec![(0, 5), (2, 6)];\n        assert!(is_transversal_consistent(\n            \u0026transversal1_2,\n            \u0026graph,\n            quotient1.clone()\n        ));\n        let transversal1_3 = vec![(0, 0), (2, 6)];\n        assert!(!is_transversal_consistent(\n            \u0026transversal1_3,\n            \u0026graph,\n            quotient1.clone()\n        ));\n\n        let quotient2: QuotientGraphEncoding = QuotientGraphEncoding(\n            vec![EdgeEncoding(0, 1), EdgeEncoding(0, 4), EdgeEncoding(1, 2)],\n            vec![\n                (0, vec![0, 5, 7]),\n                (1, vec![1, 3, 6]),\n                (2, vec![2]),\n                (4, vec![4]),\n            ],\n        );\n        let transversal2_1 = vec![(0, 0), (1, 1), (2, 2), (4, 4)];\n        assert!(is_transversal_consistent(\n            \u0026transversal2_1,\n            \u0026graph,\n            quotient2.clone()\n        ));\n        let transversal2_2 = vec![(0, 5), (1, 6), (2, 2), (4, 4)];\n        assert!(is_transversal_consistent(\n            \u0026transversal2_2,\n            \u0026graph,\n            quotient2.clone()\n        ));\n        let transversal2_3 = vec![(0, 0), (1, 6), (2, 2), (4, 4)];\n        assert!(!is_transversal_consistent(\n            \u0026transversal2_3,\n            \u0026graph,\n            quotient2.clone()\n        ));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_is_transversal_consistent_false() -\u003e Result\u003c(), Error\u003e {\n        let mut graph = Graph::new_ordered(8);\n        graph.add_edge(0, 1)?;\n        graph.add_edge(0, 4)?;\n        graph.add_edge(1, 7)?;\n        graph.add_edge(2, 3)?;\n        graph.add_edge(2, 6)?;\n        graph.add_edge(3, 6)?;\n        graph.add_edge(4, 5)?;\n        graph.add_edge(6, 7)?;\n\n        let quotient: QuotientGraphEncoding = QuotientGraphEncoding(\n            vec![\n                EdgeEncoding(0, 1),\n                EdgeEncoding(0, 4),\n                EdgeEncoding(1, 5),\n                EdgeEncoding(4, 5),\n            ],\n            vec![\n                (0, vec![0, 2]),\n                (1, vec![1, 3]),\n                (4, vec![4, 6]),\n                (5, vec![5, 7]),\n            ],\n        );\n\n        for pick0 in [0, 2] {\n            for pick1 in [1, 3] {\n                for pick4 in [4, 6] {\n                    for pick5 in [5, 7] {\n                        let transversal = vec![(0, pick0), (1, pick1), (4, pick4), (5, pick5)];\n                        assert!(!is_transversal_consistent(\n                            \u0026transversal,\n                            \u0026graph,\n                            quotient.clone()\n                        ));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[1200640,1201375],"length":1,"stats":{"Line":2},"fn_name":"is_transversal_consistent"},{"line":11,"address":[1200951,1200707,1200786],"length":1,"stats":{"Line":6},"fn_name":null},{"line":12,"address":[1201038,1201168,1200983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[803403,803376],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1201133,1201198,1201314],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[803424,803451],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":21,"address":[1201293,1201339],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1201357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1200926],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>